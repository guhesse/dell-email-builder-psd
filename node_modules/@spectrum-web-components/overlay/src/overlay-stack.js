"use strict";import{ActiveOverlay as g}from"./ActiveOverlay.js";import{OverlayTimer as f}from"./overlay-timer.js";import"../active-overlay.js";import{findOverlaysRootedInOverlay as p,parentOverlayOf as v}from"./overlay-utils.js";import{getDeepElementFromPoint as b}from"@spectrum-web-components/shared/src/get-deep-element-from-point.js";function C(s){return s.button===0}function O(s){return!!(s.metaKey||s.altKey||s.ctrlKey||s.shiftKey)}function h(){return new Promise(s=>requestAnimationFrame(()=>s()))}export class OverlayStack{constructor(){this.overlays=[];this.preventMouseRootClose=!1;this.root=document.body;this.handlingResize=!1;this.overlayTimer=new f;this.canTabTrap=!0;this.trappingInited=!1;this._eventsAreBound=!1;this._bodyMarginsApplied=!1;this.forwardContextmenuEvent=async e=>{var o;const t=this.overlays[this.overlays.length-1];!this.trappingInited||t.interaction!=="modal"||e.target!==this.overlayHolder||(e.stopPropagation(),e.preventDefault(),await this.closeTopOverlay(),(o=b(e.clientX,e.clientY))==null||o.dispatchEvent(new MouseEvent("contextmenu",e)))};this.handleOverlayClose=e=>{const{root:t}=e;t&&this.closeOverlaysForRoot(t)};this.handleMouseCapture=e=>{const t=this.topOverlay;if(!e.target||!t||!t.overlayContent||O(e)||!C(e)){this.preventMouseRootClose=!0;return}if(e.target instanceof Node){if(e.composedPath().indexOf(t.overlayContent)>=0){this.preventMouseRootClose=!0;return}this.preventMouseRootClose=!1}};this._doesNotCloseOnFirstClick=!1;this.handleMouse=e=>{var i;if(this._doesNotCloseOnFirstClick){this._doesNotCloseOnFirstClick=!1;return}if(this.preventMouseRootClose||e.defaultPrevented)return;const t=[];let o=this.overlays.length;for(;o&&t.length===0;){o-=1;const a=this.overlays[o],l=e.composedPath();(!l.includes(a.trigger)||a.interaction!=="hover")&&!l.includes(a.overlayContent)&&t.push(a)}let r=(i=this.topOverlay)==null?void 0:i.root,n=v(r);for(;r&&n;)t.push(n),n=v(r),r=n==null?void 0:n.root;n&&t.push(n),t.forEach(a=>this.hideAndCloseOverlay(a))};this.handleKeydown=e=>{e.code==="Escape"&&this.closeTopOverlay()};this.handleResize=()=>{this.handlingResize||(this.handlingResize=!0,requestAnimationFrame(async()=>{const e=this.overlays.map(t=>t.updateOverlayPosition());await Promise.all(e),this.handlingResize=!1}))};this.initTabTrapping()}initTabTrapping(){if(document.readyState==="loading"){document.addEventListener("readystatechange",()=>{this.initTabTrapping()},{once:!0});return}if(this.trappingInited)return;if(this.trappingInited=!0,this.document.body.shadowRoot){this.canTabTrap=!1;return}if(this.document.body.attachShadow({mode:"open"}),!this.document.body.shadowRoot)return;const e=this.document.body.shadowRoot;e.innerHTML=`
            <style>
            :host {
                position: relative;
            }
            #actual {
                position: relative;
                height: calc(100% - var(--swc-body-margins-block, 0px));
                z-index: 0;
                min-height: calc(100vh - var(--swc-body-margins-block, 0px));
            }
            #holder {
                display: none;
                align-items: center;
                justify-content: center;
                flex-flow: column;
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
            }
            [name="open"]::slotted(*) {
                pointer-events: all;
            }
            #actual[aria-hidden] + #holder {
                display: flex;
            }
            </style>
            <div id="actual"><slot></slot></div>
            <div id="holder"><slot name="open"></slot></div>
        `,this.tabTrapper=e.querySelector("#actual"),this.overlayHolder=e.querySelector("#holder"),this.tabTrapper.attachShadow({mode:"open"}),this.tabTrapper.shadowRoot&&(this.tabTrapper.shadowRoot.innerHTML="<slot></slot>"),this.overlayHolder.addEventListener("contextmenu",this.forwardContextmenuEvent,!0),requestAnimationFrame(()=>{this.applyBodyMargins(),new ResizeObserver(()=>{this.applyBodyMargins()}).observe(document.body)})}applyBodyMargins(){const{marginLeft:e,marginRight:t,marginTop:o,marginBottom:r}=getComputedStyle(document.body),n=parseFloat(e)===0&&parseFloat(t)===0&&parseFloat(o)===0&&parseFloat(r)===0;n&&!this._bodyMarginsApplied||(this.tabTrapper.style.setProperty("--swc-body-margins-inline",`calc(${e} + ${t})`),this.tabTrapper.style.setProperty("--swc-body-margins-block",`calc(${o} + ${r})`),this._bodyMarginsApplied=!n)}startTabTrapping(){this.initTabTrapping(),this.canTabTrap&&(this.tabTrapper.tabIndex=-1,this.tabTrapper.setAttribute("aria-hidden","true"))}stopTabTrapping(){!this.canTabTrap||!this.trappingInited||(this.tabTrapper.removeAttribute("tabindex"),this.tabTrapper.removeAttribute("aria-hidden"))}get document(){return this.root.ownerDocument||document}get topOverlay(){return this.overlays.slice(-1)[0]}findOverlayForContent(e){for(const t of this.overlays)if(e===t.overlayContent)return t}addEventListeners(){this._eventsAreBound||(this._eventsAreBound=!0,this.document.addEventListener("click",this.handleMouseCapture,!0),this.document.addEventListener("click",this.handleMouse),this.document.addEventListener("keydown",this.handleKeydown),this.document.addEventListener("sp-overlay-close",this.handleOverlayClose),window.addEventListener("resize",this.handleResize))}isClickOverlayActiveForTrigger(e){return this.overlays.some(t=>e===t.trigger&&t.interaction==="click")}async openOverlay(e){if(this.addEventListeners(),this.findOverlayForContent(e.content))return!1;e.notImmediatelyClosable&&(this._doesNotCloseOnFirstClick=!0),e.interaction==="modal"&&this.startTabTrapping();const t=e.content,{trigger:o}=e;if(t.overlayWillOpenCallback&&t.overlayWillOpenCallback({trigger:o}),e.delayed){const a=[this.overlayTimer.openTimer(e.content)];e.abortPromise&&a.push(e.abortPromise);const l=await Promise.race(a);if(l)return t.overlayOpenCancelledCallback&&t.overlayOpenCancelledCallback({trigger:o}),l}if(e.root&&this.closeOverlaysForRoot(e.root),e.interaction==="click")this.closeAllHoverOverlays();else if(e.interaction==="hover"&&this.isClickOverlayActiveForTrigger(e.trigger))return!0;const r=g.create(e);this.overlays.length&&this.overlays[this.overlays.length-1].obscure(r.interaction),document.body.appendChild(r),await h(),this.overlays.push(r),await r.updateComplete,this.addOverlayEventListeners(r),typeof t.open!="undefined"&&(await h(),t.open=!0);let n=()=>{};if(t.overlayOpenCallback){const{trigger:i}=r,{overlayOpenCallback:a}=t;n=async()=>await a({trigger:i})}return await r.openCallback(n),!1}addOverlayEventListeners(e){switch(e.addEventListener("close",()=>{this.hideAndCloseOverlay(e,!0)}),e.interaction){case"replace":this.addReplaceOverlayEventListeners(e);break;case"inline":this.addInlineOverlayEventListeners(e);break}}addReplaceOverlayEventListeners(e){e.addEventListener("keydown",t=>{const{code:o}=t;o==="Tab"&&(t.stopPropagation(),this.closeOverlay(e.overlayContent),e.tabbingAway=!0,e.trigger.focus(),e.trigger.dispatchEvent(new KeyboardEvent("keydown",t)))})}addInlineOverlayEventListeners(e){e.trigger.addEventListener("keydown",e.handleInlineTriggerKeydown),e.addEventListener("keydown",t=>{const{code:o,shiftKey:r}=t;if(o!=="Tab")return;if(e.tabbingAway=!0,r){const i=document.createElement("span");i.tabIndex=-1,e.trigger.hasAttribute("slot")&&(i.slot=e.trigger.slot),e.trigger.insertAdjacentElement("afterend",i),i.focus(),i.remove();return}t.stopPropagation();const n=e.trigger;typeof n.open!="undefined"&&(n.open=!1),this.closeOverlay(e.overlayContent),e.trigger.focus()})}closeOverlay(e){this.overlayTimer.close(e),requestAnimationFrame(()=>{const t=this.findOverlayForContent(e),o=[t];o.push(...p(t,this.overlays)),o.forEach(r=>this.hideAndCloseOverlay(r))})}closeAllHoverOverlays(){for(const e of this.overlays)e.interaction==="hover"&&this.hideAndCloseOverlay(e,!1)}closeOverlaysForRoot(e){const t=[];for(const o of this.overlays)o.root&&o.root===e&&(t.push(o),t.push(...p(o,this.overlays)));t.forEach(o=>this.hideAndCloseOverlay(o,!0,!0))}async manageFocusAfterCloseWhenOverlaysRemain(e,t){const o=this.overlays[this.overlays.length-1];if(o.feature(),o.interaction==="modal"||o.hasModalRoot){if(e)return;await(t||o).focus()}else this.stopTabTrapping()}manageFocusAfterCloseWhenLastOverlay(e){this.stopTabTrapping();const t=e.interaction==="modal",o=e.receivesFocus==="auto",r=e.interaction==="replace",n=e.interaction==="inline",i=(r||n)&&!e.tabbingAway;if(e.tabbingAway=!1,!t&&!o&&!i)return;const l=e.overlayContent.getRootNode().activeElement;let d,c;const u=()=>e.overlayContent.contains(l),y=()=>(d=e.trigger.getRootNode(),c=d.activeElement,d.contains(c)),m=()=>d.host&&d.host===c;(t||u()||y()||m())&&e.trigger.focus()}async hideAndCloseOverlay(e,t,o){if(!e)return;const r=e.overlayContent;if(typeof r.overlayWillCloseCallback!="undefined"){const{trigger:i}=e;if(r.overlayWillCloseCallback({trigger:i}))return}if(await e.hide(t),typeof r.open!="undefined"&&(r.open=!1),r.overlayCloseCallback){const{trigger:i}=e;await r.overlayCloseCallback({trigger:i})}if(e.state!="dispose")return;const n=this.overlays.indexOf(e);n>=0&&this.overlays.splice(n,1),this.overlays.length?await this.manageFocusAfterCloseWhenOverlaysRemain(o||e.interaction==="hover",e.trigger):this.manageFocusAfterCloseWhenLastOverlay(e),await e.updateComplete,e.remove(),e.dispose(),e.trigger.dispatchEvent(new CustomEvent("sp-closed",{bubbles:!0,composed:!0,cancelable:!0,detail:{interaction:e.interaction}}))}closeTopOverlay(){return this.hideAndCloseOverlay(this.topOverlay,!0)}}
//# sourceMappingURL=overlay-stack.js.map
