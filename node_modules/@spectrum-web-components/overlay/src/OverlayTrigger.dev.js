"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import {
  html,
  SpectrumElement
} from "@spectrum-web-components/base";
import {
  property,
  state
} from "@spectrum-web-components/base/src/decorators.js";
import { firstFocusableIn } from "@spectrum-web-components/shared/src/first-focusable-in.js";
import {
  isAndroid,
  isIOS
} from "@spectrum-web-components/shared/src/platform.js";
import { openOverlay } from "./loader.dev.js";
import overlayTriggerStyles from "./overlay-trigger.css.js";
export const LONGPRESS_INSTRUCTIONS = {
  touch: "Double tap and long press for additional options",
  keyboard: "Press Space or Alt+Down Arrow for additional options",
  mouse: "Click and hold for additional options"
};
const _OverlayTrigger = class extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.placement = "bottom";
    this.offset = 6;
    this.disabled = false;
    this.hasLongpressContent = false;
    this._longpressId = `longpress-describedby-descriptor`;
    this.abortOverlay = () => {
      return;
    };
    this.openStatePromise = Promise.resolve();
  }
  static get styles() {
    return [overlayTriggerStyles];
  }
  handleClose(event) {
    if (event && event.detail.interaction !== this.open && event.detail.interaction !== this.type) {
      return;
    }
    this.removeAttribute("open");
  }
  render() {
    return html`
            <slot
                id="trigger"
                @click=${this.onTrigger}
                @longpress=${this.onTrigger}
                @mouseenter=${this.onTrigger}
                @mouseleave=${this.onTrigger}
                @focusin=${this.onTrigger}
                @focusout=${this.onTrigger}
                @sp-closed=${this.handleClose}
                @slotchange=${this.onTargetSlotChange}
                name="trigger"
            ></slot>
            <div id="overlay-content">
                <slot
                    @slotchange=${this.onClickSlotChange}
                    name="click-content"
                ></slot>
                <slot
                    @slotchange=${this.onLongpressSlotChange}
                    name="longpress-content"
                ></slot>
                <slot
                    @slotchange=${this.onHoverSlotChange}
                    name="hover-content"
                ></slot>
                <slot name=${this._longpressId}></slot>
            </div>
        `;
  }
  updated(changes) {
    super.updated(changes);
    if (this.disabled && changes.has("disabled")) {
      this.closeAllOverlays();
      return;
    }
    if (changes.has("open")) {
      this.manageOpen();
    }
    if (changes.has("hasLongpressContent")) {
      this.manageLongpressDescriptor();
    }
  }
  manageLongpressDescriptor() {
    const trigger = this.querySelector(
      '[slot="trigger"]'
    );
    const ariaDescribedby = trigger.getAttribute("aria-describedby");
    let descriptors = ariaDescribedby ? ariaDescribedby.split(/\s+/) : [];
    if (this.hasLongpressContent) {
      if (!this.longpressDescriptor) {
        this.longpressDescriptor = document.createElement(
          "div"
        );
        this.longpressDescriptor.id = this._longpressId;
        this.longpressDescriptor.slot = this._longpressId;
      }
      const messageType = isIOS() || isAndroid() ? "touch" : "keyboard";
      this.longpressDescriptor.textContent = LONGPRESS_INSTRUCTIONS[messageType];
      this.appendChild(this.longpressDescriptor);
      descriptors.push(this._longpressId);
    } else {
      if (this.longpressDescriptor)
        this.longpressDescriptor.remove();
      descriptors = descriptors.filter(
        (descriptor) => descriptor !== this._longpressId
      );
    }
    if (descriptors.length) {
      trigger.setAttribute("aria-describedby", descriptors.join(" "));
    } else {
      trigger.removeAttribute("aria-describedby");
    }
  }
  closeAllOverlays() {
    if (this.abortOverlay)
      this.abortOverlay(true);
    [
      "closeClickOverlay",
      "closeHoverOverlay",
      "closeLongpressOverlay"
    ].forEach(async (name) => {
      const canClose = this[name];
      if (canClose == null)
        return;
      delete this[name];
      (await canClose)();
    });
    this.overlaidContent = void 0;
  }
  manageOpen() {
    var _a;
    const openHandlers = {
      click: () => this.onTriggerClick(),
      hover: () => this.onTriggerMouseEnter(),
      longpress: () => this.onTriggerLongpress(),
      none: () => this.closeAllOverlays()
    };
    openHandlers[(_a = this.open) != null ? _a : "none"]();
  }
  async openOverlay(target, interaction, content, options) {
    this.openStatePromise = new Promise(
      (res) => this.openStateResolver = res
    );
    this.addEventListener(
      "sp-opened",
      () => {
        this.openStateResolver();
      },
      { once: true }
    );
    this.overlaidContent = content;
    return _OverlayTrigger.openOverlay(
      target,
      interaction,
      content,
      options
    );
  }
  get overlayOptions() {
    return {
      offset: this.offset,
      placement: this.placement,
      receivesFocus: !this.type || this.type === "inline" || this.open === "hover" ? void 0 : "auto"
    };
  }
  onTrigger(event) {
    const mouseIsEnteringHoverContent = event.type === "mouseleave" && this.open === "hover" && event.relatedTarget === this.overlaidContent;
    if (mouseIsEnteringHoverContent && this.overlaidContent) {
      this.overlaidContent.addEventListener(
        "mouseleave",
        (event2) => {
          const mouseIsEnteringTrigger = event2.relatedTarget === this.targetContent;
          if (mouseIsEnteringTrigger) {
            return;
          }
          this.onTrigger(
            event2
          );
        },
        { once: true }
      );
      return;
    }
    if (this.disabled)
      return;
    switch (event.type) {
      case "mouseenter":
      case "focusin":
        if (!this.open && this.hoverContent) {
          this.open = "hover";
        }
        return;
      case "mouseleave":
      case "focusout":
        if (this.open === "hover") {
          this.handleClose();
        }
        return;
      case "click":
        if (this.clickContent) {
          this.open = event.type;
        }
        return;
      case "longpress":
        if (this.longpressContent) {
          this._longpressEvent = event;
          this.open = event.type;
        }
        return;
    }
  }
  prepareToFocusOverlayContent(overlayContent) {
    if (this.type !== "modal") {
      return;
    }
    const firstFocusable = firstFocusableIn(overlayContent);
    if (!firstFocusable) {
      overlayContent.tabIndex = 0;
    }
  }
  async onTriggerClick() {
    if (!this.targetContent || !this.clickContent || this.closeClickOverlay) {
      return;
    }
    const { targetContent, clickContent } = this;
    this.closeAllOverlays();
    this.prepareToFocusOverlayContent(clickContent);
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = true;
    }
    this.closeClickOverlay = this.openOverlay(
      targetContent,
      this.type ? this.type : "click",
      clickContent,
      this.overlayOptions
    );
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = false;
    }
  }
  async onTriggerLongpress() {
    var _a, _b;
    if (!this.targetContent || !this.longpressContent || this.closeLongpressOverlay) {
      return;
    }
    const { targetContent, longpressContent } = this;
    this.closeAllOverlays();
    this.prepareToFocusOverlayContent(longpressContent);
    const notImmediatelyClosable = ((_b = (_a = this._longpressEvent) == null ? void 0 : _a.detail) == null ? void 0 : _b.source) !== "keyboard";
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = true;
    }
    this.closeLongpressOverlay = this.openOverlay(
      targetContent,
      this.type ? this.type : "longpress",
      longpressContent,
      {
        ...this.overlayOptions,
        receivesFocus: "auto",
        notImmediatelyClosable
      }
    );
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = false;
    }
    this._longpressEvent = void 0;
  }
  async onTriggerMouseEnter() {
    if (!this.targetContent || !this.hoverContent || this.closeHoverOverlay) {
      return;
    }
    const abortPromise = new Promise((res) => {
      this.abortOverlay = res;
    });
    const { targetContent, hoverContent } = this;
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = true;
    }
    this.closeHoverOverlay = this.openOverlay(
      targetContent,
      "hover",
      hoverContent,
      {
        abortPromise,
        ...this.overlayOptions
      }
    );
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = false;
    }
  }
  onClickSlotChange(event) {
    this.clickContent = this.extractSlotContentFromEvent(event);
    this.manageOpen();
  }
  onLongpressSlotChange(event) {
    this.longpressContent = this.extractSlotContentFromEvent(event);
    this.hasLongpressContent = !!this.longpressContent || !!this.closeLongpressOverlay;
    this.manageOpen();
  }
  onHoverSlotChange(event) {
    this.hoverContent = this.extractSlotContentFromEvent(event);
    this.manageOpen();
  }
  onTargetSlotChange(event) {
    this.targetContent = this.extractSlotContentFromEvent(event);
  }
  extractSlotContentFromEvent(event) {
    const slot = event.target;
    const nodes = slot.assignedNodes({ flatten: true });
    return nodes.find((node) => node instanceof HTMLElement);
  }
  async getUpdateComplete() {
    const complete = await super.getUpdateComplete();
    await this.openStatePromise;
    return complete;
  }
  disconnectedCallback() {
    this.closeAllOverlays();
    super.disconnectedCallback();
  }
};
export let OverlayTrigger = _OverlayTrigger;
OverlayTrigger.openOverlay = async (target, interaction, content, options) => {
  return openOverlay(target, interaction, content, options);
};
__decorateClass([
  property({ reflect: true })
], OverlayTrigger.prototype, "placement", 2);
__decorateClass([
  property()
], OverlayTrigger.prototype, "type", 2);
__decorateClass([
  property({ type: Number, reflect: true })
], OverlayTrigger.prototype, "offset", 2);
__decorateClass([
  property({ reflect: true })
], OverlayTrigger.prototype, "open", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], OverlayTrigger.prototype, "disabled", 2);
__decorateClass([
  state()
], OverlayTrigger.prototype, "hasLongpressContent", 2);
//# sourceMappingURL=OverlayTrigger.dev.js.map
