"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import {
  html,
  SpectrumElement
} from "@spectrum-web-components/base";
import { ifDefined } from "@spectrum-web-components/base/src/directives.js";
import { property } from "@spectrum-web-components/base/src/decorators.js";
import { reparentChildren } from "@spectrum-web-components/shared/src/reparent-children.js";
import { firstFocusableIn } from "@spectrum-web-components/shared/src/first-focusable-in.js";
import styles from "./active-overlay.css.js";
import { parentOverlayOf } from "./overlay-utils.dev.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  offset,
  shift,
  size
} from "@floating-ui/dom";
const stateMachine = {
  initial: "idle",
  states: {
    idle: {
      on: {
        active: "active"
      }
    },
    active: {
      on: {
        hiding: "hiding",
        idle: "idle"
      }
    },
    hiding: {
      on: {
        dispose: "dispose"
      }
    },
    dispose: {
      on: {
        disposed: "disposed"
      }
    },
    disposed: {
      on: {}
    }
  }
};
const stateTransition = (state, event) => {
  if (!state)
    return stateMachine.initial;
  if (!event)
    return state;
  return stateMachine.states[state].on[event] || state;
};
const getFallbackPlacements = (placement) => {
  var _a;
  const fallbacks = {
    left: ["right", "bottom", "top"],
    "left-start": ["right-start", "bottom", "top"],
    "left-end": ["right-end", "bottom", "top"],
    right: ["left", "bottom", "top"],
    "right-start": ["left-start", "bottom", "top"],
    "right-end": ["left-end", "bottom", "top"],
    top: ["bottom", "left", "right"],
    "top-start": ["bottom-start", "left", "right"],
    "top-end": ["bottom-end", "left", "right"],
    bottom: ["top", "left", "right"],
    "bottom-start": ["top-start", "left", "right"],
    "bottom-end": ["top-end", "left", "right"]
  };
  return (_a = fallbacks[placement]) != null ? _a : [placement];
};
const _ActiveOverlay = class extends SpectrumElement {
  constructor() {
    super();
    this.contentAnimationPromise = Promise.resolve(true);
    this.resolveContentAnimationPromise = () => {
      return;
    };
    this._state = stateTransition();
    this.animating = false;
    this.theme = {};
    this.tabbingAway = false;
    this.offset = 6;
    this.skidding = 0;
    this.interaction = "hover";
    this.positionAnimationFrame = 0;
    this.willNotifyClosed = false;
    this.isConstrained = false;
    this.updateOverlayPosition = () => {
      if (this.interaction !== "modal" && this.cleanup) {
        this.dispatchEvent(new Event("close"));
        return;
      }
      this.setOverlayPosition();
    };
    this.resetOverlayPosition = () => {
      this.style.removeProperty("max-height");
      this.style.removeProperty("height");
      this.initialHeight = void 0;
      this.isConstrained = false;
      this.offsetHeight;
      this.setOverlayPosition();
    };
    this.setOverlayPosition = async () => {
      if (!this.placement || this.placement === "none") {
        return;
      }
      await (document.fonts ? document.fonts.ready : Promise.resolve());
      function roundByDPR(num) {
        const dpr = window.devicePixelRatio || 1;
        return Math.round(num * dpr) / dpr || -1e4;
      }
      const REQUIRED_DISTANCE_TO_EDGE = 8;
      const MIN_OVERLAY_HEIGHT = 100;
      const flipMiddleware = this.virtualTrigger ? flip({
        padding: REQUIRED_DISTANCE_TO_EDGE,
        fallbackPlacements: getFallbackPlacements(this.placement)
      }) : flip({
        padding: REQUIRED_DISTANCE_TO_EDGE
      });
      const middleware = [
        offset({
          mainAxis: this.offset,
          crossAxis: this.skidding
        }),
        shift({ padding: REQUIRED_DISTANCE_TO_EDGE }),
        flipMiddleware,
        size({
          padding: REQUIRED_DISTANCE_TO_EDGE,
          apply: ({
            availableWidth,
            availableHeight,
            rects: { floating }
          }) => {
            const maxHeight = Math.max(
              MIN_OVERLAY_HEIGHT,
              Math.floor(availableHeight)
            );
            const actualHeight = floating.height;
            this.initialHeight = !this.isConstrained && !this.virtualTrigger ? actualHeight : this.initialHeight || actualHeight;
            this.isConstrained = actualHeight < this.initialHeight || maxHeight <= actualHeight;
            const appliedHeight = this.isConstrained ? `${maxHeight}px` : "";
            Object.assign(this.style, {
              maxWidth: `${Math.floor(availableWidth)}px`,
              maxHeight: appliedHeight,
              height: appliedHeight
            });
          }
        })
      ];
      if (this.overlayContentTip) {
        middleware.push(arrow({ element: this.overlayContentTip }));
      }
      const { x, y, placement, middlewareData } = await computePosition(
        this.virtualTrigger || this.trigger,
        this,
        {
          placement: this.placement,
          middleware,
          strategy: "fixed"
        }
      );
      Object.assign(this.style, {
        top: "0px",
        left: "0px",
        transform: `translate(${roundByDPR(x)}px, ${roundByDPR(y)}px)`
      });
      if (placement !== this.getAttribute("actual-placement")) {
        this.setAttribute("actual-placement", placement);
        this.overlayContent.setAttribute("placement", placement);
      }
      if (this.overlayContentTip && middlewareData.arrow) {
        const { x: arrowX, y: arrowY } = middlewareData.arrow;
        Object.assign(this.overlayContentTip.style, {
          left: arrowX != null ? `${roundByDPR(arrowX)}px` : "",
          top: arrowY != null ? `${roundByDPR(arrowY)}px` : "",
          right: "",
          bottom: ""
        });
      }
    };
    this.handleInlineTriggerKeydown = (event) => {
      const { code, shiftKey } = event;
      if (code !== "Tab")
        return;
      if (shiftKey) {
        this.tabbingAway = true;
        this.dispatchEvent(new Event("close"));
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      this.focus();
    };
    this.stealOverlayContentPromise = Promise.resolve();
    this.stealOverlayContentPromise = new Promise(
      (res) => this.stealOverlayContentResolver = res
    );
  }
  get state() {
    return this._state;
  }
  set state(state) {
    const nextState = stateTransition(this.state, state);
    if (nextState === this.state) {
      return;
    }
    this._state = nextState;
    if (this.state === "active" || this.state === "hiding") {
      this.setAttribute("state", this.state);
    } else {
      this.removeAttribute("state");
    }
  }
  async focus() {
    const firstFocusable = firstFocusableIn(this);
    if (firstFocusable) {
      if (firstFocusable.updateComplete) {
        await firstFocusable.updateComplete;
      }
      const activeElement = this.getRootNode().activeElement;
      if (activeElement === this || !this.contains(activeElement)) {
        firstFocusable.focus();
      }
    } else {
      super.focus();
    }
    this.removeAttribute("tabindex");
  }
  get hasTheme() {
    return !!this.theme.color || !!this.theme.scale || !!this.theme.lang;
  }
  static get styles() {
    return [styles];
  }
  get hasModalRoot() {
    return !!this._modalRoot;
  }
  feature() {
    if (!this.contains(document.activeElement)) {
      this.tabIndex = -1;
    }
    const parentOverlay = parentOverlayOf(this.trigger);
    const parentIsModal = parentOverlay && parentOverlay.slot === "open";
    if (parentIsModal) {
      this._modalRoot = parentOverlay._modalRoot || parentOverlay;
    }
    if (this.interaction === "modal" || this._modalRoot) {
      this.slot = "open";
      if (this.interaction === "modal") {
        this.setAttribute("aria-modal", "true");
      }
      if (this._modalRoot) {
        parentOverlay == null ? void 0 : parentOverlay.feature();
      }
    }
  }
  obscure(nextOverlayInteraction) {
    if (this.slot && nextOverlayInteraction === "modal") {
      this.removeAttribute("slot");
      this.removeAttribute("aria-modal");
      if (this.interaction !== "modal") {
        const parentOverlay = parentOverlayOf(this.trigger);
        this._modalRoot = parentOverlay == null ? void 0 : parentOverlay.obscure(
          nextOverlayInteraction
        );
        return this._modalRoot;
      }
      return this;
    }
    return void 0;
  }
  async willUpdate() {
    if (this.hasUpdated)
      return;
    if (!this.overlayContent || !this.trigger)
      return;
    this.stealOverlayContent(
      this.overlayContent
    );
    this.state = "active";
    this.feature();
    if (this.placement && this.placement !== "none") {
      await this.updateOverlayPosition();
      document.addEventListener(
        "sp-update-overlays",
        this.resetOverlayPosition
      );
    }
    if (this.placement && this.placement !== "none") {
      this.contentAnimationPromise = this.applyContentAnimation("sp-overlay-fade-in");
    }
  }
  async openCallback(lifecycleCallback) {
    await this.updateComplete;
    if (this.receivesFocus) {
      await this.focus();
    }
    await lifecycleCallback();
    this.trigger.dispatchEvent(
      new CustomEvent("sp-opened", {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          interaction: this.interaction
        }
      })
    );
  }
  open(openDetail) {
    this.extractDetail(openDetail);
  }
  extractDetail(detail) {
    this.overlayContent = detail.content;
    this.overlayContentTip = detail.contentTip;
    this.trigger = detail.trigger;
    this.virtualTrigger = detail.virtualTrigger;
    this.placement = detail.placement;
    this.offset = detail.offset;
    this.skidding = detail.skidding || 0;
    this.interaction = detail.interaction;
    this.theme = detail.theme;
    this.receivesFocus = detail.receivesFocus;
    this.root = detail.root;
  }
  dispose() {
    if (this.state !== "dispose")
      return;
    if (this.timeout) {
      clearTimeout(this.timeout);
      delete this.timeout;
    }
    this.trigger.removeEventListener(
      "keydown",
      this.handleInlineTriggerKeydown
    );
    this.returnOverlayContent();
    this.state = "disposed";
    if (this.willNotifyClosed) {
      this.overlayContent.dispatchEvent(new Event("sp-overlay-closed"));
      this.willNotifyClosed = false;
    }
    if (this.cleanup) {
      this.cleanup();
    }
  }
  stealOverlayContent(element) {
    this.originalPlacement = element.getAttribute("placement");
    this.restoreContent = reparentChildren([element], this, {
      position: "beforeend",
      prepareCallback: (el) => {
        const slotName = el.slot;
        const placement = el.placement;
        el.removeAttribute("slot");
        return (el2) => {
          el2.slot = slotName;
          el2.placement = placement;
        };
      }
    });
    this.stealOverlayContentResolver();
  }
  returnOverlayContent() {
    if (!this.restoreContent)
      return;
    const [element] = this.restoreContent();
    this.restoreContent = void 0;
    this.willNotifyClosed = true;
    if (this.originalPlacement) {
      element.setAttribute("placement", this.originalPlacement);
      delete this.originalPlacement;
    }
  }
  async placeOverlay() {
    if (!this.placement || this.placement === "none") {
      return;
    }
    this.cleanup = autoUpdate(
      this.virtualTrigger || this.trigger,
      this,
      this.updateOverlayPosition,
      {
        elementResize: false
      }
    );
  }
  async hide(animated = true) {
    if (this.state !== "active")
      return;
    this.state = "hiding";
    if (animated) {
      await this.applyContentAnimation("sp-overlay-fade-out");
    }
    this.state = "dispose";
  }
  schedulePositionUpdate() {
    cancelAnimationFrame(this.positionAnimationFrame);
    this.positionAnimationFrame = requestAnimationFrame(() => {
      if (this.cleanup) {
        this.updateOverlayPosition();
      } else {
        this.placeOverlay();
      }
    });
  }
  onSlotChange() {
    this.schedulePositionUpdate();
  }
  applyContentAnimation(animation) {
    if (this.placement === "none") {
      return Promise.resolve(true);
    }
    this.resolveContentAnimationPromise();
    return new Promise((resolve) => {
      this.resolveContentAnimationPromise = () => {
        resolve(false);
      };
      const contents = this.shadowRoot.querySelector(
        "#contents"
      );
      const doneHandler = (event) => {
        if (animation !== event.animationName)
          return;
        contents.removeEventListener("animationend", doneHandler);
        contents.removeEventListener("animationcancel", doneHandler);
        this.animating = false;
        resolve(event.type === "animationcancel");
      };
      contents.addEventListener("animationend", doneHandler);
      contents.addEventListener("animationcancel", doneHandler);
      contents.style.animationName = animation;
      this.animating = true;
    });
  }
  renderTheme(content) {
    const { color, scale, lang, theme } = this.theme;
    return html`
            <sp-theme
                theme=${ifDefined(theme)}
                color=${ifDefined(color)}
                scale=${ifDefined(scale)}
                lang=${ifDefined(lang)}
                part="theme"
            >
                ${content}
            </sp-theme>
        `;
  }
  render() {
    const content = html`
            <div id="contents">
                <slot @slotchange=${this.onSlotChange}></slot>
            </div>
        `;
    return this.hasTheme ? this.renderTheme(content) : content;
  }
  static create(details) {
    const overlay = new _ActiveOverlay();
    if (details.content) {
      overlay.open(details);
    }
    return overlay;
  }
  async getUpdateComplete() {
    const actions = [
      super.getUpdateComplete(),
      this.stealOverlayContentPromise
    ];
    actions.push(this.contentAnimationPromise);
    if (typeof this.overlayContent.updateComplete !== "undefined") {
      actions.push(
        this.overlayContent.updateComplete
      );
    }
    const [complete] = await Promise.all(actions);
    return complete;
  }
  disconnectedCallback() {
    document.removeEventListener(
      "sp-update-overlays",
      this.resetOverlayPosition
    );
    super.disconnectedCallback();
  }
};
export let ActiveOverlay = _ActiveOverlay;
__decorateClass([
  property()
], ActiveOverlay.prototype, "_state", 2);
__decorateClass([
  property({ reflect: true, type: Boolean })
], ActiveOverlay.prototype, "animating", 2);
__decorateClass([
  property({ reflect: true })
], ActiveOverlay.prototype, "placement", 2);
__decorateClass([
  property({ attribute: false })
], ActiveOverlay.prototype, "theme", 2);
__decorateClass([
  property({ attribute: false })
], ActiveOverlay.prototype, "receivesFocus", 2);
//# sourceMappingURL=ActiveOverlay.dev.js.map
