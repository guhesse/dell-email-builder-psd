"use strict";
import { OverlayStack } from "./overlay-stack.dev.js";
const _Overlay = class {
  /**
   *
   * @param owner the parent element we will use to position the overlay element
   * @param interaction the type of interaction that caused this overlay to be shown
   * @param overlayElement the item to display as an overlay
   */
  constructor(owner, interaction, overlayElement) {
    this.isOpen = false;
    this.owner = owner;
    this.overlayElement = overlayElement;
    this.interaction = interaction;
  }
  /**
   * Open an overlay
   *
   * @param owner the parent element we will use to position the overlay element
   * @param interaction the type of interaction that caused this overlay to be shown
   * @param overlayElement the item to display as an overlay
   * @param options display parameters
   * @param options.delayed if true delay opening of the overlay based on the global warmup/cooldown timer
   * @param options.offset distance to offset the overlay
   * @param options.placement side on which to position the overlay
   * @returns an Overlay object which can be used to close the overlay
   */
  static async open(owner, interaction, overlayElement, options) {
    const overlay = new _Overlay(owner, interaction, overlayElement);
    if (true) {
      window.__swc.warn(
        void 0,
        "The Overlay API is currently being refactored and there are likely to be breaking changes, deprecations and/or removals in a future release. The SWC team wants feedback from direct Overlay API consumers like you - please share your thoughts on the future of overlays here:",
        "https://github.com/adobe/spectrum-web-components/discussions/2764",
        {
          type: "default",
          level: "deprecation"
        }
      );
    }
    await overlay.open(options);
    return () => {
      overlay.close();
    };
  }
  static update() {
    const overlayUpdateEvent = new CustomEvent("sp-update-overlays", {
      bubbles: true,
      composed: true,
      cancelable: true
    });
    document.dispatchEvent(overlayUpdateEvent);
  }
  /**
   * Open an overlay
   *
   * @param options display parameters
   * @param options.delayed delay before opening the overlay
   * @param options.offset distance to offset the overlay
   * @param options.placement side on which to position the overlay
   * @returns a Promise that resolves to true if this operation was cancelled
   */
  async open({
    abortPromise,
    delayed,
    offset = 0,
    placement = "top",
    receivesFocus,
    notImmediatelyClosable,
    virtualTrigger,
    root
  }) {
    if (this.isOpen)
      return true;
    if (delayed === void 0) {
      delayed = this.overlayElement.hasAttribute("delayed");
    }
    const queryThemeDetail = {
      color: void 0,
      scale: void 0,
      lang: void 0,
      theme: void 0
    };
    const queryThemeEvent = new CustomEvent("sp-query-theme", {
      bubbles: true,
      composed: true,
      detail: queryThemeDetail,
      cancelable: true
    });
    this.owner.dispatchEvent(queryThemeEvent);
    const overlayDetailQuery = {};
    const queryOverlayDetailEvent = new CustomEvent("sp-overlay-query", {
      bubbles: true,
      composed: true,
      detail: overlayDetailQuery,
      cancelable: true
    });
    this.overlayElement.dispatchEvent(queryOverlayDetailEvent);
    await _Overlay.overlayStack.openOverlay({
      abortPromise,
      content: this.overlayElement,
      contentTip: overlayDetailQuery.overlayContentTipElement,
      delayed,
      offset,
      placement,
      trigger: this.owner,
      interaction: this.interaction,
      theme: queryThemeDetail,
      receivesFocus,
      root,
      notImmediatelyClosable,
      virtualTrigger,
      ...overlayDetailQuery
    });
    this.isOpen = true;
    return true;
  }
  /**
   * Close the overlay if it is open
   */
  close() {
    _Overlay.overlayStack.closeOverlay(this.overlayElement);
  }
};
export let Overlay = _Overlay;
Overlay.overlayStack = new OverlayStack();
//# sourceMappingURL=overlay.dev.js.map
