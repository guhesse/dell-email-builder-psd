"use strict";
import { ActiveOverlay } from "./ActiveOverlay.dev.js";
import { OverlayTimer } from "./overlay-timer.dev.js";
import "../active-overlay.dev.js";
import {
  findOverlaysRootedInOverlay,
  parentOverlayOf
} from "./overlay-utils.dev.js";
import { getDeepElementFromPoint } from "@spectrum-web-components/shared/src/get-deep-element-from-point.js";
function isLeftClick(event) {
  return event.button === 0;
}
function hasModifier(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function nextFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
export class OverlayStack {
  constructor() {
    this.overlays = [];
    this.preventMouseRootClose = false;
    this.root = document.body;
    this.handlingResize = false;
    this.overlayTimer = new OverlayTimer();
    this.canTabTrap = true;
    this.trappingInited = false;
    this._eventsAreBound = false;
    this._bodyMarginsApplied = false;
    this.forwardContextmenuEvent = async (event) => {
      var _a;
      const topOverlay = this.overlays[this.overlays.length - 1];
      if (!this.trappingInited || topOverlay.interaction !== "modal" || event.target !== this.overlayHolder) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      await this.closeTopOverlay();
      (_a = getDeepElementFromPoint(event.clientX, event.clientY)) == null ? void 0 : _a.dispatchEvent(
        new MouseEvent("contextmenu", event)
      );
    };
    this.handleOverlayClose = (event) => {
      const { root } = event;
      if (!root)
        return;
      this.closeOverlaysForRoot(root);
    };
    this.handleMouseCapture = (event) => {
      const topOverlay = this.topOverlay;
      if (!event.target || !topOverlay || !topOverlay.overlayContent || hasModifier(event) || !isLeftClick(event)) {
        this.preventMouseRootClose = true;
        return;
      }
      if (event.target instanceof Node) {
        const path = event.composedPath();
        if (path.indexOf(topOverlay.overlayContent) >= 0) {
          this.preventMouseRootClose = true;
          return;
        }
        this.preventMouseRootClose = false;
      }
    };
    /**
     * A "longpress" occurs before the "click" that creates it has occured.
     * In that way the first click will still be part of the "longpress" and
     * not part of closing the overlay.
     */
    this._doesNotCloseOnFirstClick = false;
    this.handleMouse = (event) => {
      var _a;
      if (this._doesNotCloseOnFirstClick) {
        this._doesNotCloseOnFirstClick = false;
        return;
      }
      if (this.preventMouseRootClose || event.defaultPrevented) {
        return;
      }
      const overlaysToClose = [];
      let index = this.overlays.length;
      while (index && overlaysToClose.length === 0) {
        index -= 1;
        const overlay2 = this.overlays[index];
        const path = event.composedPath();
        const eventPathDictatesClosure = (!path.includes(overlay2.trigger) || overlay2.interaction !== "hover") && !path.includes(overlay2.overlayContent);
        if (eventPathDictatesClosure) {
          overlaysToClose.push(overlay2);
        }
      }
      let root = (_a = this.topOverlay) == null ? void 0 : _a.root;
      let overlay = parentOverlayOf(root);
      while (root && overlay) {
        overlaysToClose.push(overlay);
        overlay = parentOverlayOf(root);
        root = overlay == null ? void 0 : overlay.root;
      }
      if (overlay) {
        overlaysToClose.push(overlay);
      }
      overlaysToClose.forEach((overlay2) => this.hideAndCloseOverlay(overlay2));
    };
    this.handleKeydown = (event) => {
      if (event.code === "Escape") {
        this.closeTopOverlay();
      }
    };
    this.handleResize = () => {
      if (this.handlingResize)
        return;
      this.handlingResize = true;
      requestAnimationFrame(async () => {
        const promises = this.overlays.map(
          (overlay) => overlay.updateOverlayPosition()
        );
        await Promise.all(promises);
        this.handlingResize = false;
      });
    };
    this.initTabTrapping();
  }
  initTabTrapping() {
    if (document.readyState === "loading") {
      document.addEventListener(
        "readystatechange",
        () => {
          this.initTabTrapping();
        },
        { once: true }
      );
      return;
    }
    if (this.trappingInited)
      return;
    this.trappingInited = true;
    if (this.document.body.shadowRoot) {
      this.canTabTrap = false;
      return;
    }
    this.document.body.attachShadow({ mode: "open" });
    if (!this.document.body.shadowRoot) {
      return;
    }
    const root = this.document.body.shadowRoot;
    root.innerHTML = `
            <style>
            :host {
                position: relative;
            }
            #actual {
                position: relative;
                height: calc(100% - var(--swc-body-margins-block, 0px));
                z-index: 0;
                min-height: calc(100vh - var(--swc-body-margins-block, 0px));
            }
            #holder {
                display: none;
                align-items: center;
                justify-content: center;
                flex-flow: column;
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
            }
            [name="open"]::slotted(*) {
                pointer-events: all;
            }
            #actual[aria-hidden] + #holder {
                display: flex;
            }
            </style>
            <div id="actual"><slot></slot></div>
            <div id="holder"><slot name="open"></slot></div>
        `;
    this.tabTrapper = root.querySelector("#actual");
    this.overlayHolder = root.querySelector("#holder");
    this.tabTrapper.attachShadow({ mode: "open" });
    if (this.tabTrapper.shadowRoot) {
      this.tabTrapper.shadowRoot.innerHTML = "<slot></slot>";
    }
    this.overlayHolder.addEventListener(
      "contextmenu",
      this.forwardContextmenuEvent,
      true
    );
    requestAnimationFrame(() => {
      this.applyBodyMargins();
      const observer = new ResizeObserver(() => {
        this.applyBodyMargins();
      });
      observer.observe(document.body);
    });
  }
  applyBodyMargins() {
    const { marginLeft, marginRight, marginTop, marginBottom } = getComputedStyle(document.body);
    const allZero = parseFloat(marginLeft) === 0 && parseFloat(marginRight) === 0 && parseFloat(marginTop) === 0 && parseFloat(marginBottom) === 0;
    if (allZero && !this._bodyMarginsApplied) {
      return;
    }
    this.tabTrapper.style.setProperty(
      "--swc-body-margins-inline",
      `calc(${marginLeft} + ${marginRight})`
    );
    this.tabTrapper.style.setProperty(
      "--swc-body-margins-block",
      `calc(${marginTop} + ${marginBottom})`
    );
    this._bodyMarginsApplied = !allZero;
  }
  startTabTrapping() {
    this.initTabTrapping();
    if (!this.canTabTrap) {
      return;
    }
    this.tabTrapper.tabIndex = -1;
    this.tabTrapper.setAttribute("aria-hidden", "true");
  }
  stopTabTrapping() {
    if (!this.canTabTrap || !this.trappingInited) {
      return;
    }
    this.tabTrapper.removeAttribute("tabindex");
    this.tabTrapper.removeAttribute("aria-hidden");
  }
  get document() {
    return this.root.ownerDocument || document;
  }
  get topOverlay() {
    return this.overlays.slice(-1)[0];
  }
  findOverlayForContent(overlayContent) {
    for (const item of this.overlays) {
      if (overlayContent === item.overlayContent) {
        return item;
      }
    }
    return void 0;
  }
  addEventListeners() {
    if (this._eventsAreBound)
      return;
    this._eventsAreBound = true;
    this.document.addEventListener("click", this.handleMouseCapture, true);
    this.document.addEventListener("click", this.handleMouse);
    this.document.addEventListener("keydown", this.handleKeydown);
    this.document.addEventListener(
      "sp-overlay-close",
      this.handleOverlayClose
    );
    window.addEventListener("resize", this.handleResize);
  }
  isClickOverlayActiveForTrigger(trigger) {
    return this.overlays.some(
      (item) => trigger === item.trigger && item.interaction === "click"
    );
  }
  async openOverlay(details) {
    this.addEventListeners();
    if (this.findOverlayForContent(details.content)) {
      return false;
    }
    if (details.notImmediatelyClosable) {
      this._doesNotCloseOnFirstClick = true;
    }
    if (details.interaction === "modal") {
      this.startTabTrapping();
    }
    const contentWithLifecycle = details.content;
    const { trigger } = details;
    if (contentWithLifecycle.overlayWillOpenCallback) {
      contentWithLifecycle.overlayWillOpenCallback({ trigger });
    }
    if (details.delayed) {
      const cancelledPromise = this.overlayTimer.openTimer(
        details.content
      );
      const promises = [cancelledPromise];
      if (details.abortPromise) {
        promises.push(details.abortPromise);
      }
      const cancelled = await Promise.race(promises);
      if (cancelled) {
        if (contentWithLifecycle.overlayOpenCancelledCallback) {
          contentWithLifecycle.overlayOpenCancelledCallback({
            trigger
          });
        }
        return cancelled;
      }
    }
    if (details.root) {
      this.closeOverlaysForRoot(details.root);
    }
    if (details.interaction === "click") {
      this.closeAllHoverOverlays();
    } else if (details.interaction === "hover" && this.isClickOverlayActiveForTrigger(details.trigger)) {
      return true;
    }
    const activeOverlay = ActiveOverlay.create(details);
    if (this.overlays.length) {
      const topOverlay = this.overlays[this.overlays.length - 1];
      topOverlay.obscure(activeOverlay.interaction);
    }
    document.body.appendChild(activeOverlay);
    await nextFrame();
    this.overlays.push(activeOverlay);
    await activeOverlay.updateComplete;
    this.addOverlayEventListeners(activeOverlay);
    if (typeof contentWithLifecycle.open !== "undefined") {
      await nextFrame();
      contentWithLifecycle.open = true;
    }
    let cb = () => {
      return;
    };
    if (contentWithLifecycle.overlayOpenCallback) {
      const { trigger: trigger2 } = activeOverlay;
      const { overlayOpenCallback } = contentWithLifecycle;
      cb = async () => await overlayOpenCallback({ trigger: trigger2 });
    }
    await activeOverlay.openCallback(cb);
    return false;
  }
  addOverlayEventListeners(activeOverlay) {
    activeOverlay.addEventListener("close", () => {
      this.hideAndCloseOverlay(
        activeOverlay,
        true
        // animated?
      );
    });
    switch (activeOverlay.interaction) {
      case "replace":
        this.addReplaceOverlayEventListeners(activeOverlay);
        break;
      case "inline":
        this.addInlineOverlayEventListeners(activeOverlay);
        break;
    }
  }
  addReplaceOverlayEventListeners(activeOverlay) {
    activeOverlay.addEventListener("keydown", (event) => {
      const { code } = event;
      if (code !== "Tab")
        return;
      event.stopPropagation();
      this.closeOverlay(activeOverlay.overlayContent);
      activeOverlay.tabbingAway = true;
      activeOverlay.trigger.focus();
      activeOverlay.trigger.dispatchEvent(
        new KeyboardEvent("keydown", event)
      );
    });
  }
  addInlineOverlayEventListeners(activeOverlay) {
    activeOverlay.trigger.addEventListener(
      "keydown",
      activeOverlay.handleInlineTriggerKeydown
    );
    activeOverlay.addEventListener("keydown", (event) => {
      const { code, shiftKey } = event;
      if (code !== "Tab")
        return;
      activeOverlay.tabbingAway = true;
      if (shiftKey) {
        const returnFocusElement = document.createElement("span");
        returnFocusElement.tabIndex = -1;
        if (activeOverlay.trigger.hasAttribute("slot")) {
          returnFocusElement.slot = activeOverlay.trigger.slot;
        }
        activeOverlay.trigger.insertAdjacentElement(
          "afterend",
          returnFocusElement
        );
        returnFocusElement.focus();
        returnFocusElement.remove();
        return;
      }
      event.stopPropagation();
      const triggerWithLifecycle = activeOverlay.trigger;
      if (typeof triggerWithLifecycle.open !== "undefined") {
        triggerWithLifecycle.open = false;
      }
      this.closeOverlay(activeOverlay.overlayContent);
      activeOverlay.trigger.focus();
    });
  }
  closeOverlay(content) {
    this.overlayTimer.close(content);
    requestAnimationFrame(() => {
      const overlayFromContent = this.findOverlayForContent(content);
      const overlaysToClose = [overlayFromContent];
      overlaysToClose.push(
        ...findOverlaysRootedInOverlay(
          overlayFromContent,
          this.overlays
        )
      );
      overlaysToClose.forEach(
        (overlay) => this.hideAndCloseOverlay(overlay)
      );
    });
  }
  closeAllHoverOverlays() {
    for (const overlay of this.overlays) {
      if (overlay.interaction === "hover") {
        this.hideAndCloseOverlay(overlay, false);
      }
    }
  }
  closeOverlaysForRoot(root) {
    const overlaysToClose = [];
    for (const overlay of this.overlays) {
      if (overlay.root && overlay.root === root) {
        overlaysToClose.push(overlay);
        overlaysToClose.push(
          ...findOverlaysRootedInOverlay(overlay, this.overlays)
        );
      }
    }
    overlaysToClose.forEach(
      (overlay) => this.hideAndCloseOverlay(overlay, true, true)
    );
  }
  async manageFocusAfterCloseWhenOverlaysRemain(returnBeforeFocus, previousTrigger) {
    const topOverlay = this.overlays[this.overlays.length - 1];
    topOverlay.feature();
    if (topOverlay.interaction === "modal" || topOverlay.hasModalRoot) {
      if (returnBeforeFocus)
        return;
      await (previousTrigger || topOverlay).focus();
    } else {
      this.stopTabTrapping();
    }
  }
  manageFocusAfterCloseWhenLastOverlay(overlay) {
    this.stopTabTrapping();
    const isModal = overlay.interaction === "modal";
    const isReceivesFocus = overlay.receivesFocus === "auto";
    const isReplace = overlay.interaction === "replace";
    const isInline = overlay.interaction === "inline";
    const isTabbingAwayFromInlineOrReplace = (isReplace || isInline) && !overlay.tabbingAway;
    overlay.tabbingAway = false;
    if (!isModal && !isReceivesFocus && !isTabbingAwayFromInlineOrReplace) {
      return;
    }
    const overlayRoot = overlay.overlayContent.getRootNode();
    const overlayContentActiveElement = overlayRoot.activeElement;
    let triggerRoot;
    let triggerActiveElement;
    const contentContainsActiveElement = () => overlay.overlayContent.contains(overlayContentActiveElement);
    const triggerRootContainsActiveElement = () => {
      triggerRoot = overlay.trigger.getRootNode();
      triggerActiveElement = triggerRoot.activeElement;
      return triggerRoot.contains(triggerActiveElement);
    };
    const triggerHostIsActiveElement = () => triggerRoot.host && triggerRoot.host === triggerActiveElement;
    if (isModal || contentContainsActiveElement() || triggerRootContainsActiveElement() || triggerHostIsActiveElement()) {
      overlay.trigger.focus();
    }
  }
  async hideAndCloseOverlay(overlay, animated, returnBeforeFocus) {
    if (!overlay) {
      return;
    }
    const contentWithLifecycle = overlay.overlayContent;
    if (typeof contentWithLifecycle.overlayWillCloseCallback !== "undefined") {
      const { trigger } = overlay;
      if (contentWithLifecycle.overlayWillCloseCallback({ trigger })) {
        return;
      }
    }
    await overlay.hide(animated);
    if (typeof contentWithLifecycle.open !== "undefined") {
      contentWithLifecycle.open = false;
    }
    if (contentWithLifecycle.overlayCloseCallback) {
      const { trigger } = overlay;
      await contentWithLifecycle.overlayCloseCallback({ trigger });
    }
    if (overlay.state != "dispose")
      return;
    const index = this.overlays.indexOf(overlay);
    if (index >= 0) {
      this.overlays.splice(index, 1);
    }
    if (this.overlays.length) {
      await this.manageFocusAfterCloseWhenOverlaysRemain(
        returnBeforeFocus || overlay.interaction === "hover",
        overlay.trigger
      );
    } else {
      this.manageFocusAfterCloseWhenLastOverlay(overlay);
    }
    await overlay.updateComplete;
    overlay.remove();
    overlay.dispose();
    overlay.trigger.dispatchEvent(
      new CustomEvent("sp-closed", {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          interaction: overlay.interaction
        }
      })
    );
  }
  closeTopOverlay() {
    return this.hideAndCloseOverlay(this.topOverlay, true);
  }
}
//# sourceMappingURL=overlay-stack.dev.js.map
