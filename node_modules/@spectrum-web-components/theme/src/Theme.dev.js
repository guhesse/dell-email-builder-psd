"use strict";
import {
  supportsAdoptingStyleSheets
} from "@spectrum-web-components/base";
const ThemeVariantValues = ["spectrum", "express"];
const ScaleValues = ["medium", "large", "medium-express", "large-express"];
const ColorValues = [
  "light",
  "lightest",
  "dark",
  "darkest",
  "light-express",
  "lightest-express",
  "dark-express",
  "darkest-express"
];
const _Theme = class extends HTMLElement {
  constructor() {
    super();
    this._dir = "";
    this._theme = "spectrum";
    this._color = "";
    this._scale = "";
    this.trackedChildren = /* @__PURE__ */ new Set();
    this._updateRequested = false;
    this._contextConsumers = /* @__PURE__ */ new Map();
    this.attachShadow({ mode: "open" });
    const node = document.importNode(_Theme.template.content, true);
    this.shadowRoot.appendChild(node);
    this.shouldAdoptStyles();
    this.addEventListener(
      "sp-query-theme",
      this.onQueryTheme
    );
    this.addEventListener(
      "sp-language-context",
      this._handleContextPresence
    );
    this.updateComplete = this.__createDeferredPromise();
  }
  static get observedAttributes() {
    return ["color", "scale", "theme", "lang", "dir"];
  }
  set dir(dir) {
    if (dir === this.dir)
      return;
    this.setAttribute("dir", dir);
    this._dir = dir;
    const targetDir = dir === "rtl" ? dir : "ltr";
    this.trackedChildren.forEach((el) => {
      el.setAttribute("dir", targetDir);
    });
  }
  get dir() {
    return this._dir;
  }
  attributeChangedCallback(attrName, old, value) {
    if (old === value) {
      return;
    }
    if (attrName === "color") {
      this.color = value;
    } else if (attrName === "scale") {
      this.scale = value;
    } else if (attrName === "lang" && !!value) {
      this.lang = value;
      this._provideContext();
    } else if (attrName === "theme") {
      this.theme = value;
    } else if (attrName === "dir") {
      this.dir = value;
    }
  }
  requestUpdate() {
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.styleElement(this);
    } else {
      this.shouldAdoptStyles();
    }
  }
  get theme() {
    const themeFragments = _Theme.themeFragmentsByKind.get("theme");
    const { name } = themeFragments && themeFragments.get("default") || {};
    return this._theme || name || "";
  }
  set theme(newValue) {
    if (newValue === this._theme)
      return;
    const theme = !!newValue && ThemeVariantValues.includes(newValue) ? newValue : this.theme;
    if (theme !== this._theme) {
      this._theme = theme;
      this.requestUpdate();
    }
    if (theme) {
      this.setAttribute("theme", theme);
    } else {
      this.removeAttribute("theme");
    }
  }
  get color() {
    const themeFragments = _Theme.themeFragmentsByKind.get("color");
    const { name } = themeFragments && themeFragments.get("default") || {};
    return this._color || name || "";
  }
  set color(newValue) {
    if (newValue === this._color)
      return;
    const color = !!newValue && ColorValues.includes(newValue) ? newValue : this.color;
    if (color !== this._color) {
      this._color = color;
      this.requestUpdate();
    }
    if (color) {
      this.setAttribute("color", color);
    } else {
      this.removeAttribute("color");
    }
  }
  get scale() {
    const themeFragments = _Theme.themeFragmentsByKind.get("scale");
    const { name } = themeFragments && themeFragments.get("default") || {};
    return this._scale || name || "";
  }
  set scale(newValue) {
    if (newValue === this._scale)
      return;
    const scale = !!newValue && ScaleValues.includes(newValue) ? newValue : this.scale;
    if (scale !== this._scale) {
      this._scale = scale;
      this.requestUpdate();
    }
    if (scale) {
      this.setAttribute("scale", scale);
    } else {
      this.removeAttribute("scale");
    }
  }
  get styles() {
    const themeKinds = [
      ..._Theme.themeFragmentsByKind.keys()
    ];
    const getStyle = (fragments, name, kind) => {
      const currentStyles = kind && kind !== "theme" && this.theme === "express" ? fragments.get(`${name}-express`) : fragments.get(name);
      const isAppliedFragment = name === "spectrum" || !kind || this.hasAttribute(kind);
      if (currentStyles && isAppliedFragment) {
        return currentStyles.styles;
      }
      return;
    };
    const styles = themeKinds.reduce((acc, kind) => {
      const kindFragments = _Theme.themeFragmentsByKind.get(
        kind
      );
      let style;
      if (kind === "app" || kind === "core") {
        style = getStyle(kindFragments, kind);
      } else {
        const { [kind]: name } = this;
        style = getStyle(kindFragments, name, kind);
      }
      if (style) {
        acc.push(style);
      }
      return acc;
    }, []);
    if (true) {
      const issues = [];
      const checkForAttribute = (name, resolvedValue, actualValue) => {
        var _a;
        const themeModifier = this.theme && this.theme !== "spectrum" ? `-${this.theme}` : "";
        if (!resolvedValue) {
          issues.push(
            `You have not explicitly set the "${name}" attribute and there is no default value on which to fallback.`
          );
        } else if (!actualValue) {
          issues.push(
            `You have not explicitly set the "${name}" attribute, the default value ("${resolvedValue}") is being used as a fallback.`
          );
        } else if (!((_a = _Theme.themeFragmentsByKind.get(name)) == null ? void 0 : _a.get(
          resolvedValue + (name === "theme" ? "" : themeModifier)
        ))) {
          issues.push(
            `You have set "${name}='${resolvedValue}'" but the associated theme fragment has not been loaded.`
          );
        }
      };
      checkForAttribute("theme", this.theme, this._theme);
      checkForAttribute("color", this.color, this._color);
      checkForAttribute("scale", this.scale, this._scale);
      if (issues.length) {
        window.__swc.warn(
          this,
          "You are leveraging an <sp-theme> element and the following issues may disrupt your theme delivery:",
          "https://opensource.adobe.com/spectrum-web-components/components/theme/#example",
          {
            issues
          }
        );
      }
    }
    return [...styles];
  }
  static get template() {
    if (!this.templateElement) {
      this.templateElement = document.createElement("template");
      this.templateElement.innerHTML = "<slot></slot>";
    }
    return this.templateElement;
  }
  __createDeferredPromise() {
    return new Promise((resolve) => {
      this.__resolve = resolve;
    });
  }
  onQueryTheme(event) {
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    const { detail: theme } = event;
    theme.color = this.color || void 0;
    theme.scale = this.scale || void 0;
    theme.lang = this.lang || document.documentElement.lang || navigator.language;
    theme.theme = this.theme || void 0;
  }
  connectedCallback() {
    this.shouldAdoptStyles();
    if (window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
    _Theme.instances.add(this);
    if (!this.hasAttribute("dir")) {
      let dirParent = this.assignedSlot || this.parentNode;
      while (dirParent !== document.documentElement && !(dirParent instanceof _Theme)) {
        dirParent = dirParent.assignedSlot || dirParent.parentNode || dirParent.host;
      }
      this.dir = dirParent.dir === "rtl" ? dirParent.dir : "ltr";
    }
  }
  disconnectedCallback() {
    _Theme.instances.delete(this);
  }
  startManagingContentDirection(el) {
    this.trackedChildren.add(el);
  }
  stopManagingContentDirection(el) {
    this.trackedChildren.delete(el);
  }
  async shouldAdoptStyles() {
    if (!this._updateRequested) {
      this.updateComplete = this.__createDeferredPromise();
      this._updateRequested = true;
      this._updateRequested = await false;
      this.adoptStyles();
      this.__resolve(true);
    }
  }
  adoptStyles() {
    const styles = this.styles;
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow && window.ShadyCSS.ScopingShim) {
      const fragmentCSS = [];
      for (const [kind, fragments] of _Theme.themeFragmentsByKind) {
        for (const [name, { styles: styles2 }] of fragments) {
          if (name === "default")
            continue;
          let cssText = styles2.cssText;
          if (!_Theme.defaultFragments.has(name)) {
            cssText = cssText.replace(
              ":host",
              `:host([${kind}='${name}'])`
            );
          }
          fragmentCSS.push(cssText);
        }
      }
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(
        fragmentCSS,
        this.localName
      );
      window.ShadyCSS.prepareTemplate(_Theme.template, this.localName);
    } else if (supportsAdoptingStyleSheets) {
      const styleSheets = [];
      for (const style of styles) {
        styleSheets.push(
          style.styleSheet
        );
      }
      this.shadowRoot.adoptedStyleSheets = styleSheets;
    } else {
      const styleNodes = this.shadowRoot.querySelectorAll("style");
      styleNodes.forEach((element) => element.remove());
      styles.forEach((s) => {
        const style = document.createElement("style");
        style.textContent = s.cssText;
        this.shadowRoot.appendChild(style);
      });
    }
  }
  static registerThemeFragment(name, kind, styles) {
    const fragmentMap = _Theme.themeFragmentsByKind.get(kind) || /* @__PURE__ */ new Map();
    if (fragmentMap.size === 0) {
      _Theme.themeFragmentsByKind.set(kind, fragmentMap);
      fragmentMap.set("default", { name, styles });
      _Theme.defaultFragments.add(name);
    }
    fragmentMap.set(name, { name, styles });
    _Theme.instances.forEach((instance) => instance.shouldAdoptStyles());
  }
  _provideContext() {
    this._contextConsumers.forEach(
      ([callback, unsubscribe]) => callback(this.lang, unsubscribe)
    );
  }
  _handleContextPresence(event) {
    const target = event.composedPath()[0];
    if (this._contextConsumers.has(target)) {
      return;
    }
    this._contextConsumers.set(target, [
      event.detail.callback,
      () => this._contextConsumers.delete(target)
    ]);
    const [callback, unsubscribe] = this._contextConsumers.get(target) || [];
    if (callback && unsubscribe) {
      callback(
        this.lang || document.documentElement.lang || navigator.language,
        unsubscribe
      );
    }
  }
};
export let Theme = _Theme;
Theme.themeFragmentsByKind = /* @__PURE__ */ new Map();
Theme.defaultFragments = /* @__PURE__ */ new Set(["spectrum"]);
Theme.instances = /* @__PURE__ */ new Set();
//# sourceMappingURL=Theme.dev.js.map
