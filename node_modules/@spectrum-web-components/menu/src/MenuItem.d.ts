import { CSSResultArray, PropertyValues, TemplateResult } from '@spectrum-web-components/base';
import '@spectrum-web-components/icons-ui/icons/sp-icon-checkmark100.js';
import { Focusable } from '@spectrum-web-components/shared/src/focusable.js';
import '@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js';
import type { Menu } from './Menu.js';
export declare class MenuItemRemovedEvent extends Event {
    constructor();
    get item(): MenuItem;
    _item: MenuItem;
    focused: boolean;
    reset(item: MenuItem): void;
}
export declare class MenuItemAddedOrUpdatedEvent extends Event {
    constructor();
    set focusRoot(root: Menu | undefined);
    set selectionRoot(root: Menu);
    get item(): MenuItem;
    _item: MenuItem;
    set currentAncestorWithSelects(ancestor: Menu | undefined);
    get currentAncestorWithSelects(): Menu | undefined;
    _currentAncestorWithSelects?: Menu;
    reset(item: MenuItem): void;
}
export declare type MenuItemChildren = {
    icon: Element[];
    content: Node[];
};
declare const MenuItem_base: typeof Focusable & {
    new (...args: any[]): import("@spectrum-web-components/shared/src/like-anchor.js").LikeAnchorInterface;
    prototype: import("@spectrum-web-components/shared/src/like-anchor.js").LikeAnchorInterface;
};
/**
 * @element sp-menu-item
 *
 * @slot - text content to display within the Menu Item
 * @slot icon - icon element to be placed at the start of the Menu Item
 * @slot value - content placed at the end of the Menu Item like values, keyboard shortcuts, etc.
 * @fires sp-menu-item-added - announces the item has been added so a parent menu can take ownerships
 * @fires sp-menu-item-removed - announces when removed from the DOM so the parent menu can remove ownership and update selected state
 */
export declare class MenuItem extends MenuItem_base {
    static get styles(): CSSResultArray;
    static instanceCount: number;
    private isInSubmenu;
    active: boolean;
    focused: boolean;
    selected: boolean;
    get value(): string;
    set value(value: string);
    private _value;
    /**
     * @private
     */
    get itemText(): string;
    hasSubmenu: boolean;
    noWrap: boolean;
    private anchorElement;
    get focusElement(): HTMLElement;
    get itemChildren(): MenuItemChildren;
    private _itemChildren?;
    constructor();
    open: boolean;
    click(): void;
    private handleClickCapture;
    private proxyFocus;
    private shouldProxyClick;
    protected breakItemChildrenCache(): void;
    protected render(): TemplateResult;
    protected manageSubmenu(event: Event & {
        target: HTMLSlotElement;
    }): void;
    private handleRemoveActive;
    private handlePointerdown;
    protected firstUpdated(changes: PropertyValues): void;
    protected closeOverlaysForRoot(): void;
    closeOverlay?: () => Promise<void>;
    protected handleSubmenuClick(): void;
    protected handlePointerenter(): void;
    protected leaveTimeout?: ReturnType<typeof setTimeout>;
    protected handlePointerleave(): void;
    /**
     * When there is a `change` event in the submenu for this item
     * then we "click" this item to cascade the selection up the
     * menu tree allowing all submenus between the initial selection
     * and the root of the tree to have their selection changes and
     * be closed.
     */
    protected handleSubmenuChange: () => void;
    protected handleSubmenuPointerenter: () => void;
    openOverlay(): Promise<void>;
    updateAriaSelected(): void;
    setRole(role: string): void;
    protected updated(changes: PropertyValues<this>): void;
    connectedCallback(): void;
    _parentElement: HTMLElement;
    disconnectedCallback(): void;
    triggerUpdate(): Promise<void>;
    menuData: {
        focusRoot?: Menu;
        selectionRoot?: Menu;
    };
}
declare global {
    interface GlobalEventHandlersEventMap {
        'sp-menu-item-added-or-updated': MenuItemAddedOrUpdatedEvent;
        'sp-menu-item-removed': MenuItemRemovedEvent;
    }
}
export {};
