"use strict";
import {
  getContainingBlock,
  getWindow,
  isContainingBlock
} from "@floating-ui/utils/dom";
import { VirtualTrigger } from "./VirtualTrigger.dev.js";
export const topLayerOverTransforms = () => ({
  name: "topLayer",
  async fn(middlewareArguments) {
    const {
      x,
      y,
      elements: { reference, floating }
    } = middlewareArguments;
    let onTopLayer = false;
    let topLayerIsFloating = false;
    let withinReference = false;
    const diffCoords = {
      x: 0,
      y: 0
    };
    try {
      onTopLayer = onTopLayer || floating.matches(":popover-open");
    } catch (error) {
    }
    try {
      onTopLayer = onTopLayer || floating.matches(":open");
    } catch (error) {
    }
    try {
      onTopLayer = onTopLayer || floating.matches(":modal");
    } catch (error) {
    }
    topLayerIsFloating = onTopLayer;
    const dialogAncestorQueryEvent = new Event("floating-ui-dialog-test", {
      composed: true,
      bubbles: true
    });
    floating.addEventListener(
      "floating-ui-dialog-test",
      (event) => {
        event.composedPath().forEach((el) => {
          withinReference = withinReference || el === reference;
          if (el === floating || el.localName !== "dialog")
            return;
          try {
            onTopLayer = onTopLayer || el.matches(":modal");
          } catch (error) {
          }
        });
      },
      { once: true }
    );
    floating.dispatchEvent(dialogAncestorQueryEvent);
    let overTransforms = false;
    if (!(reference instanceof VirtualTrigger)) {
      const root = withinReference ? reference : floating;
      const containingBlock = isContainingBlock(root) ? root : getContainingBlock(root);
      if (containingBlock !== null && getWindow(containingBlock) !== containingBlock) {
        const css = getComputedStyle(containingBlock);
        overTransforms = // the `transform` property
        css.transform !== "none" || // the `filter` property for anything other than "none"
        (css.filter ? css.filter !== "none" : false) || // a value of "paint", "layout", "strict", or "content" for `contain`
        ["paint", "layout", "strict", "content"].some(
          (value) => (css.contain || "").includes(value)
        );
      }
      if (onTopLayer && overTransforms && containingBlock) {
        const rect = containingBlock.getBoundingClientRect();
        diffCoords.x = rect.x;
        diffCoords.y = rect.y;
      }
    }
    if (onTopLayer && topLayerIsFloating) {
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
    if (onTopLayer) {
      return {
        x,
        y,
        data: diffCoords
      };
    }
    return {
      x: x - diffCoords.x,
      y: y - diffCoords.y,
      data: diffCoords
    };
  }
});
//# sourceMappingURL=topLayerOverTransforms.dev.js.map
