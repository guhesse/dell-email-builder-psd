"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import {
  html,
  SpectrumElement
} from "@spectrum-web-components/base";
import {
  property,
  query
} from "@spectrum-web-components/base/src/decorators.js";
import { openOverlay } from "@spectrum-web-components/overlay/src/loader.js";
import tooltipStyles from "./tooltip.css.js";
export class TooltipProxy extends HTMLElement {
  disconnectedCallback() {
    this.dispatchEvent(new Event("disconnected"));
  }
}
customElements.define("tooltip-proxy", TooltipProxy);
const _Tooltip = class extends SpectrumElement {
  constructor() {
    super();
    this._tooltipId = `sp-tooltip-describedby-helper-${_Tooltip.instanceCount++}`;
    this.selfManaged = false;
    this.offset = 6;
    this.hadTooltipId = false;
    this.open = false;
    this.placement = "top";
    this._variant = "";
    this.abortOverlay = () => {
      return;
    };
    this.openOverlay = () => {
      const parentElement = this.parentElement;
      const abortPromise = new Promise((res) => {
        this.abortOverlay = res;
      });
      this.closeOverlayCallback = openOverlay(parentElement, "hover", this, {
        abortPromise,
        offset: this.offset,
        placement: this.placement
      });
    };
    this.closeOverlay = async (event) => {
      const pointerIsEnteringTooltip = event && event.type === "pointerleave" && event.relatedTarget === this;
      if (pointerIsEnteringTooltip) {
        this.addEventListener(
          "pointerleave",
          (event2) => {
            const pointerIsEnteringParnet = event2.relatedTarget === this.parentElement;
            if (pointerIsEnteringParnet) {
              return;
            }
            this.closeOverlay(event2);
          },
          { once: true }
        );
        return;
      }
      if (this.abortOverlay)
        this.abortOverlay(true);
      if (!this.closeOverlayCallback)
        return;
      (await this.closeOverlayCallback)();
      delete this.closeOverlayCallback;
    };
    this.addEventListener("sp-overlay-query", this.onOverlayQuery);
  }
  static get styles() {
    return [tooltipStyles];
  }
  get variant() {
    return this._variant;
  }
  set variant(variant) {
    if (variant === this.variant) {
      return;
    }
    if (["info", "positive", "negative"].includes(variant)) {
      this.setAttribute("variant", variant);
      this._variant = variant;
      return;
    }
    this.removeAttribute("variant");
    this._variant = "";
  }
  onOverlayQuery(event) {
    if (!event.target)
      return;
    const target = event.target;
    if (target !== this)
      return;
    event.detail.overlayContentTipElement = this.tipElement;
  }
  generateProxy() {
    if (this._proxy) {
      return;
    }
    this._proxy = document.createElement("tooltip-proxy");
    this._proxy.id = this._tooltipId;
    this._proxy.hidden = true;
    this._proxy.slot = "hidden-tooltip-content";
    this._proxy.setAttribute("role", "tooltip");
    this._proxy.addEventListener("disconnected", this.closeOverlay);
  }
  overlayWillOpenCallback({
    trigger
  }) {
    this.setAttribute("aria-hidden", "true");
    this.generateProxy();
    this._proxy.textContent = this.textContent;
    const ariaDescribedby = trigger.getAttribute("aria-describedby") || "";
    this.hadTooltipId = ariaDescribedby.search(this._tooltipId) > -1;
    this.insertAdjacentElement("beforebegin", this._proxy);
    if (this.hadTooltipId)
      return;
    if (ariaDescribedby) {
      trigger.setAttribute(
        "aria-describedby",
        `${ariaDescribedby} ${this._tooltipId}`
      );
    } else {
      trigger.setAttribute("aria-describedby", `${this._tooltipId}`);
    }
  }
  overlayOpenCancelledCallback({
    trigger
  }) {
    this.overlayCloseCallback({ trigger });
  }
  overlayCloseCallback({ trigger }) {
    const ariaDescribedby = trigger.getAttribute("aria-describedby") || "";
    let descriptors = ariaDescribedby.split(/\s+/);
    if (!this.hadTooltipId) {
      descriptors = descriptors.filter(
        (descriptor) => descriptor !== this._tooltipId
      );
    }
    if (descriptors.length) {
      trigger.setAttribute("aria-describedby", descriptors.join(" "));
    } else {
      trigger.removeAttribute("aria-describedby");
    }
    this.removeAttribute("aria-hidden");
    this.removeProxy();
  }
  removeProxy() {
    this._proxy.remove();
  }
  manageTooltip() {
    const parentElement = this.parentElement;
    if (this.selfManaged) {
      if (this.slot) {
        this.previousSlot = this.slot;
      }
      this.slot = "self-managed-tooltip";
      parentElement.addEventListener("pointerenter", this.openOverlay);
      parentElement.addEventListener("focusin", this.openOverlay);
      parentElement.addEventListener("pointerleave", this.closeOverlay);
      parentElement.addEventListener("focusout", this.closeOverlay);
    } else {
      if (this.previousSlot) {
        this.slot = this.previousSlot;
      } else if (this.slot === "self-managed-tooltip") {
        this.removeAttribute("slot");
      }
      parentElement.removeEventListener("pointerenter", this.openOverlay);
      parentElement.removeEventListener("focusin", this.openOverlay);
      parentElement.removeEventListener(
        "pointerleave",
        this.closeOverlay
      );
      parentElement.removeEventListener("focusout", this.closeOverlay);
    }
  }
  render() {
    return html`
            <slot name="icon"></slot>
            <span id="label"><slot></slot></span>
            <span id="tip"></span>
        `;
  }
  async update(changed) {
    if (changed.has("open") && this.selfManaged) {
      if (this.open) {
        this.openOverlay();
      } else {
        this.closeOverlay();
      }
    }
    this.generateProxy();
    super.update(changed);
  }
  updated(changed) {
    super.updated(changed);
    if (changed.has("selfManaged")) {
      this.manageTooltip();
    }
  }
};
export let Tooltip = _Tooltip;
Tooltip.instanceCount = 0;
__decorateClass([
  property({ type: Boolean, attribute: "self-managed" })
], Tooltip.prototype, "selfManaged", 2);
__decorateClass([
  property({ type: Number, reflect: true })
], Tooltip.prototype, "offset", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], Tooltip.prototype, "open", 2);
__decorateClass([
  property({ reflect: true })
], Tooltip.prototype, "placement", 2);
__decorateClass([
  query("#tip")
], Tooltip.prototype, "tipElement", 2);
__decorateClass([
  property({ type: String })
], Tooltip.prototype, "variant", 1);
//# sourceMappingURL=Tooltip.dev.js.map
