"use strict";
import "@spectrum-web-components/tooltip/sp-tooltip.js";
import {
  elementUpdated,
  expect,
  fixture,
  html,
  oneEvent
} from "@open-wc/testing";
import "@spectrum-web-components/button/sp-button.js";
import { testForLitDevWarnings } from "../../../test/testing-helpers.js";
describe("Tooltip", () => {
  testForLitDevWarnings(
    async () => await fixture(
      html`
                    <sp-tooltip>Help text.</sp-tooltip>
                `
    )
  );
  it("loads", async () => {
    const el = await fixture(
      html`
                <sp-tooltip>Help text.</sp-tooltip>
            `
    );
    await elementUpdated(el);
    await expect(el).to.be.accessible();
  });
  it("self manages", async () => {
    const button = await fixture(
      html`
                <sp-button>
                    This is a button.
                    <sp-tooltip self-managed>Help text.</sp-tooltip>
                </sp-button>
            `
    );
    const el = button.querySelector("sp-tooltip");
    await elementUpdated(el);
    await expect(button).to.be.accessible();
    const opened = oneEvent(button, "sp-opened");
    button.focus();
    await opened;
    await elementUpdated(el);
    expect(el.open).to.be.true;
    await expect(button).to.be.accessible();
    const closed = oneEvent(button, "sp-closed");
    button.blur();
    await closed;
    await elementUpdated(el);
    expect(el.open).to.be.false;
  });
  it('allows pointer to enter the "tooltip" without closing the "tooltip"', async () => {
    const button = await fixture(
      html`
                <sp-button>
                    This is a button.
                    <sp-tooltip self-managed placement="bottom">
                        Help text.
                    </sp-tooltip>
                </sp-button>
            `
    );
    const el = button.querySelector("sp-tooltip");
    await elementUpdated(el);
    await expect(button).to.be.accessible();
    let opened = oneEvent(button, "sp-opened");
    button.dispatchEvent(new PointerEvent("pointerenter"));
    button.dispatchEvent(
      new PointerEvent("pointerleave", {
        relatedTarget: el
      })
    );
    el.dispatchEvent(
      new PointerEvent("pointerleave", {
        relatedTarget: button
      })
    );
    await opened;
    await elementUpdated(el);
    expect(el.open).to.be.true;
    await expect(button).to.be.accessible();
    let closed = oneEvent(button, "sp-closed");
    button.dispatchEvent(new PointerEvent("pointerleave"));
    await closed;
    await elementUpdated(el);
    expect(el.open).to.be.false;
    opened = oneEvent(button, "sp-opened");
    button.dispatchEvent(new PointerEvent("pointerenter"));
    button.dispatchEvent(
      new PointerEvent("pointerleave", {
        relatedTarget: el
      })
    );
    await opened;
    await elementUpdated(el);
    closed = oneEvent(button, "sp-closed");
    el.dispatchEvent(new PointerEvent("pointerleave"));
    await closed;
    await elementUpdated(el);
  });
  it("cleans up when self manages", async () => {
    const button = await fixture(
      html`
                <sp-button>
                    This is a button.
                    <sp-tooltip self-managed>Help text.</sp-tooltip>
                </sp-button>
            `
    );
    const el = button.querySelector("sp-tooltip");
    await elementUpdated(el);
    const opened = oneEvent(button, "sp-opened");
    button.focus();
    await opened;
    await elementUpdated(el);
    expect(el.open).to.be.true;
    let activeOverlay = document.querySelector("active-overlay");
    expect(activeOverlay).to.not.be.null;
    const closed = oneEvent(button, "sp-closed");
    button.remove();
    await closed;
    activeOverlay = document.querySelector("active-overlay");
    expect(activeOverlay).to.be.null;
  });
  it("accepts variants", async () => {
    const el = await fixture(
      html`
                <sp-tooltip variant="negative">Help text.</sp-tooltip>
            `
    );
    await elementUpdated(el);
    expect(el.variant).to.equal("negative");
    expect(el.getAttribute("variant")).to.equal("negative");
    el.variant = "info";
    await elementUpdated(el);
    expect(el.variant).to.equal("info");
    expect(el.getAttribute("variant")).to.equal("info");
    el.setAttribute("variant", "positive");
    await elementUpdated(el);
    expect(el.variant).to.equal("positive");
    expect(el.getAttribute("variant")).to.equal("positive");
    el.removeAttribute("variant");
    await elementUpdated(el);
    expect(el.variant).to.equal("");
    expect(el.hasAttribute("variant")).to.be.false;
  });
  it("validates variants", async () => {
    const el = await fixture(
      html`
                <sp-tooltip variant="other">Help text.</sp-tooltip>
            `
    );
    await elementUpdated(el);
    expect(el.variant).to.equal("");
    expect(el.hasAttribute("variant")).to.be.false;
    el.variant = "info";
    await elementUpdated(el);
    expect(el.variant).to.equal("info");
    expect(el.getAttribute("variant")).to.equal("info");
    el.variant = "info";
    await elementUpdated(el);
    expect(el.variant).to.equal("info");
    expect(el.getAttribute("variant")).to.equal("info");
  });
  it("answers tip query", async () => {
    const el = await fixture(
      html`
                <sp-tooltip placement="top">Help text.</sp-tooltip>
            `
    );
    await elementUpdated(el);
    const overlayDetailQuery = {};
    const queryOverlayDetailEvent = new CustomEvent("sp-overlay-query", {
      bubbles: true,
      composed: true,
      detail: overlayDetailQuery,
      cancelable: true
    });
    el.dispatchEvent(queryOverlayDetailEvent);
    expect(overlayDetailQuery.overlayContentTipElement).to.exist;
    if (overlayDetailQuery.overlayContentTipElement) {
      expect(overlayDetailQuery.overlayContentTipElement.id).to.equal(
        "tip"
      );
    }
  });
});
//# sourceMappingURL=tooltip.test.js.map
