{
  "version": 3,
  "sources": ["PlacementController.ts"],
  "sourcesContent": ["/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nimport type {\n    ReactiveController,\n    ReactiveElement,\n} from '@spectrum-web-components/base';\nimport {\n    arrow,\n    autoUpdate,\n    computePosition,\n    flip,\n    offset,\n    Placement,\n    shift,\n    size,\n} from '@floating-ui/dom';\nimport type { VirtualTrigger } from './VirtualTrigger.js';\nimport { topLayerOverTransforms } from './topLayerOverTransforms.js';\nimport type { OpenableElement } from './overlay-types.js';\nimport type { Overlay } from './Overlay.js';\n\ntype OverlayOptionsV1 = {\n    abortPromise?: Promise<boolean>;\n    delayed?: boolean;\n    offset?: number | [number, number]; // supporting multi-axis\n    placement: Placement;\n    notImmediatelyClosable?: boolean; // rename or place behind other API options\n    receivesFocus?: 'auto';\n    root?: HTMLElement;\n    tipPadding?: number;\n    trigger: HTMLElement | VirtualTrigger;\n    type?: 'modal' | 'page' | 'hint' | 'auto' | 'manual';\n};\n\nfunction roundByDPR(num?: number): number {\n    if (typeof num === 'undefined') return 0;\n    const dpr = window.devicePixelRatio || 1;\n    return Math.round(num * dpr) / dpr ?? -10000;\n}\n\n// See: https://spectrum.adobe.com/page/popover/#Container-padding\nconst REQUIRED_DISTANCE_TO_EDGE = 8;\n// See: https://github.com/adobe/spectrum-web-components/issues/910\nconst MIN_OVERLAY_HEIGHT = 100;\n\nconst getFallbackPlacements = (placement: Placement): Placement[] => {\n    const fallbacks: Record<Placement, Placement[]> = {\n        left: ['right', 'bottom', 'top'],\n        'left-start': ['right-start', 'bottom', 'top'],\n        'left-end': ['right-end', 'bottom', 'top'],\n        right: ['left', 'bottom', 'top'],\n        'right-start': ['left-start', 'bottom', 'top'],\n        'right-end': ['left-end', 'bottom', 'top'],\n        top: ['bottom', 'left', 'right'],\n        'top-start': ['bottom-start', 'left', 'right'],\n        'top-end': ['bottom-end', 'left', 'right'],\n        bottom: ['top', 'left', 'right'],\n        'bottom-start': ['top-start', 'left', 'right'],\n        'bottom-end': ['top-end', 'left', 'right'],\n    };\n    return fallbacks[placement] ?? [placement];\n};\n\nexport const placementUpdatedSymbol = Symbol('placement updated');\n\nexport class PlacementController implements ReactiveController {\n    private cleanup?: () => void;\n\n    initialHeight?: number;\n\n    isConstrained?: boolean;\n\n    private host!: ReactiveElement & { elements: OpenableElement[] };\n\n    private options!: OverlayOptionsV1;\n\n    private originalPlacements = new WeakMap<HTMLElement, Placement>();\n\n    private target!: HTMLElement;\n\n    constructor(host: ReactiveElement & { elements: OpenableElement[] }) {\n        this.host = host;\n        // Add the controller after the MutationObserver has been created in preparation\n        // for the `hostConnected`/`hostDisconnected` callbacks to be run.\n        this.host.addController(this);\n    }\n\n    public async placeOverlay(\n        target: HTMLElement = this.target,\n        options: OverlayOptionsV1 = this.options\n    ): Promise<void> {\n        this.target = target;\n        this.options = options;\n        if (!target || !options) return;\n\n        const cleanup = autoUpdate(\n            options.trigger,\n            target,\n            this.updatePlacement,\n            {\n                elementResize: false,\n                layoutShift: false,\n            }\n        );\n        this.cleanup = () => {\n            this.host.elements?.forEach((element) => {\n                element.addEventListener(\n                    'sp-closed',\n                    () => {\n                        const placement = this.originalPlacements.get(element);\n                        if (placement) {\n                            element.setAttribute('placement', placement);\n                        }\n                        this.originalPlacements.delete(element);\n                    },\n                    { once: true }\n                );\n            });\n            cleanup();\n        };\n    }\n\n    allowPlacementUpdate = false;\n\n    updatePlacement = (): void => {\n        if (\n            !this.allowPlacementUpdate &&\n            this.options.type !== 'modal' &&\n            this.cleanup\n        ) {\n            this.target.dispatchEvent(new Event('close', { bubbles: true }));\n            return;\n        }\n        this.computePlacement();\n        this.allowPlacementUpdate = false;\n    };\n\n    async computePlacement(): Promise<void> {\n        const { options, target } = this;\n\n        await (document.fonts ? document.fonts.ready : Promise.resolve());\n\n        const flipMiddleware = !(options.trigger instanceof HTMLElement)\n            ? flip({\n                  padding: REQUIRED_DISTANCE_TO_EDGE,\n                  fallbackPlacements: getFallbackPlacements(options.placement),\n              })\n            : flip();\n\n        const [mainAxis = 0, crossAxis = 0] = Array.isArray(options?.offset)\n            ? options.offset\n            : [options.offset, 0];\n\n        const tipElement = this.host.elements.find(\n            (el) => el.tipElement\n        )?.tipElement;\n\n        const middleware = [\n            offset({\n                mainAxis,\n                crossAxis,\n            }),\n            shift({ padding: REQUIRED_DISTANCE_TO_EDGE }),\n            flipMiddleware,\n            size({\n                padding: REQUIRED_DISTANCE_TO_EDGE,\n                apply: ({\n                    availableWidth,\n                    availableHeight,\n                    rects: { floating },\n                }) => {\n                    const maxHeight = Math.max(\n                        MIN_OVERLAY_HEIGHT,\n                        Math.floor(availableHeight)\n                    );\n                    const actualHeight = floating.height;\n                    this.initialHeight = !this.isConstrained // && !this.virtualTrigger\n                        ? actualHeight\n                        : this.initialHeight || actualHeight;\n                    this.isConstrained =\n                        actualHeight < this.initialHeight ||\n                        maxHeight <= actualHeight;\n                    const appliedHeight = this.isConstrained\n                        ? `${maxHeight}px`\n                        : '';\n                    Object.assign(target.style, {\n                        maxWidth: `${Math.floor(availableWidth)}px`,\n                        maxHeight: appliedHeight,\n                        height: appliedHeight,\n                    });\n                },\n            }),\n            ...(tipElement\n                ? [\n                      arrow({\n                          element: tipElement,\n                          padding:\n                              options.tipPadding || REQUIRED_DISTANCE_TO_EDGE,\n                      }),\n                  ]\n                : []),\n            topLayerOverTransforms(),\n        ];\n        const { x, y, placement, middlewareData } = await computePosition(\n            options.trigger,\n            target,\n            {\n                placement: options.placement,\n                middleware,\n                strategy: 'fixed',\n            }\n        );\n        Object.assign(target.style, {\n            top: '0px',\n            left: '0px',\n            translate: `${roundByDPR(x)}px ${roundByDPR(y)}px`,\n        });\n\n        target.setAttribute('actual-placement', placement);\n        this.host.elements?.forEach((element) => {\n            this.originalPlacements.set(\n                element,\n                element.getAttribute('placement') as Placement\n            );\n            element.setAttribute('placement', placement);\n        });\n\n        if (tipElement && middlewareData.arrow) {\n            const { x: arrowX, y: arrowY } = middlewareData.arrow;\n\n            Object.assign(tipElement.style, {\n                top:\n                    placement.startsWith('right') ||\n                    placement.startsWith('left')\n                        ? '0px'\n                        : '',\n                left:\n                    placement.startsWith('bottom') ||\n                    placement.startsWith('top')\n                        ? '0px'\n                        : '',\n                translate: `${roundByDPR(arrowX)}px ${roundByDPR(arrowY)}px`,\n            });\n        }\n    }\n\n    public resetOverlayPosition = (): void => {\n        if (!this.target || !this.options) return;\n\n        this.target.style.removeProperty('max-height');\n        this.target.style.removeProperty('height');\n        this.initialHeight = undefined;\n        this.isConstrained = false;\n        // force paint\n        this.host.offsetHeight;\n        this.computePlacement();\n    };\n\n    hostConnected(): void {\n        document.addEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n\n    hostUpdated(): void {\n        if (!(this.host as Overlay).open) {\n            this.cleanup?.();\n            this.cleanup = undefined;\n        }\n    }\n\n    hostDisconnected(): void {\n        this.cleanup?.();\n        this.cleanup = undefined;\n        document.removeEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": ["arrow", "autoUpdate", "computePosition", "flip", "offset", "shift", "size", "topLayerOverTransforms", "roundByDPR", "num", "dpr", "REQUIRED_DISTANCE_TO_EDGE", "MIN_OVERLAY_HEIGHT", "getFallbackPlacements", "placement", "_a", "host", "target", "options", "cleanup", "element", "_b", "flipMiddleware", "mainAxis", "crossAxis", "tipElement", "el", "middleware", "availableWidth", "availableHeight", "floating", "maxHeight", "actualHeight", "appliedHeight", "x", "y", "middlewareData", "arrowX", "arrowY"]
}
