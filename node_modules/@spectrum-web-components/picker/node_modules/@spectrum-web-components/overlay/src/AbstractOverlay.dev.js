"use strict";
import { SpectrumElement } from "@spectrum-web-components/base";
import { reparentChildren } from "@spectrum-web-components/shared/src/reparent-children.js";
import { OverlayTimer } from "./overlay-timer.dev.js";
export const overlayTimer = new OverlayTimer();
export const noop = () => {
  return;
};
export class BeforetoggleClosedEvent extends Event {
  constructor() {
    super("beforetoggle", {
      bubbles: false,
      composed: false
    });
    this.currentState = "open";
    this.newState = "closed";
  }
}
export class BeforetoggleOpenEvent extends Event {
  constructor() {
    super("beforetoggle", {
      bubbles: false,
      composed: false
    });
    this.currentState = "closed";
    this.newState = "open";
  }
}
export const guaranteedAllTransitionend = (el, action, cb) => {
  const abortController = new AbortController();
  const runningTransitions = /* @__PURE__ */ new Map();
  const cleanup = () => {
    abortController.abort();
    cb();
  };
  let guarantee2;
  let guarantee3;
  const guarantee1 = requestAnimationFrame(() => {
    guarantee2 = requestAnimationFrame(() => {
      guarantee3 = requestAnimationFrame(() => {
        cleanup();
      });
    });
  });
  const handleTransitionend = (event) => {
    if (event.target !== el) {
      return;
    }
    runningTransitions.set(
      event.propertyName,
      runningTransitions.get(event.propertyName) - 1
    );
    if (!runningTransitions.get(event.propertyName)) {
      runningTransitions.delete(event.propertyName);
    }
    if (runningTransitions.size === 0) {
      cleanup();
    }
  };
  const handleTransitionrun = (event) => {
    if (event.target !== el) {
      return;
    }
    if (!runningTransitions.has(event.propertyName)) {
      runningTransitions.set(event.propertyName, 0);
    }
    runningTransitions.set(
      event.propertyName,
      runningTransitions.get(event.propertyName) + 1
    );
    cancelAnimationFrame(guarantee1);
    cancelAnimationFrame(guarantee2);
    cancelAnimationFrame(guarantee3);
  };
  el.addEventListener("transitionrun", handleTransitionrun, {
    signal: abortController.signal
  });
  el.addEventListener("transitionend", handleTransitionend, {
    signal: abortController.signal
  });
  el.addEventListener("transitioncancel", handleTransitionend, {
    signal: abortController.signal
  });
  action();
};
export function nextFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
export function forcePaint() {
  document.body.offsetHeight;
}
export class AbstractOverlay extends SpectrumElement {
  constructor() {
    super(...arguments);
    this.dispose = noop;
    this.offset = 6;
    this.willPreventClose = false;
  }
  async applyFocus(_targetOpenState, _focusEl) {
    return;
  }
  async ensureOnDOM(_targetOpenState) {
    return;
  }
  async makeTransition(_targetOpenState) {
    return null;
  }
  async manageDelay(_targetOpenState) {
    return;
  }
  async manageDialogOpen() {
    return;
  }
  async managePopoverOpen() {
    return;
  }
  managePosition() {
    return;
  }
  get open() {
    return false;
  }
  set open(_open) {
    return;
  }
  get state() {
    return "closed";
  }
  set state(_state) {
    return;
  }
  manuallyKeepOpen() {
    return;
  }
  static update() {
    const overlayUpdateEvent = new CustomEvent("sp-update-overlays", {
      bubbles: true,
      composed: true,
      cancelable: true
    });
    document.dispatchEvent(overlayUpdateEvent);
  }
  static async open(triggerOrContent, interactionOrOptions, content, optionsV1) {
    var _a, _b, _c, _d;
    await import("@spectrum-web-components/overlay/sp-overlay.js");
    const v2 = arguments.length === 2;
    const overlayContent = content || triggerOrContent;
    const overlay = new this();
    let restored = false;
    overlay.dispose = () => {
      overlay.addEventListener("sp-closed", () => {
        if (!restored) {
          restoreContent();
          restored = true;
        }
        requestAnimationFrame(() => {
          overlay.remove();
        });
      });
      overlay.open = false;
      overlay.dispose = noop;
    };
    const restoreContent = reparentChildren([overlayContent], overlay, {
      position: "beforeend",
      prepareCallback: (el) => {
        const slot = el.slot;
        el.removeAttribute("slot");
        return () => {
          el.slot = slot;
        };
      }
    });
    const v1 = !v2 && overlayContent && optionsV1;
    if (v1) {
      if (true) {
        window.__swc.warn(
          overlay,
          `You are interacting with an ${overlay.localName} element via a deprecated imperative API. This API will be removed in a future version of the SWC library. Consider leveraging an ${overlay.localName} directly.`,
          "https://opensource.adobe.com/spectrum-web-components/components/overlay/",
          { level: "deprecation" }
        );
      }
      const trigger = triggerOrContent;
      const interaction = interactionOrOptions;
      const options2 = optionsV1;
      overlay.delayed = options2.delayed || overlayContent.hasAttribute("delayed");
      overlay.receivesFocus = (_a = options2.receivesFocus) != null ? _a : "auto";
      overlay.triggerElement = options2.virtualTrigger || trigger;
      overlay.type = interaction === "modal" ? "modal" : interaction === "hover" ? "hint" : "auto";
      overlay.offset = (_b = options2.offset) != null ? _b : 6;
      overlay.placement = options2.placement;
      overlay.willPreventClose = !!options2.notImmediatelyClosable;
      trigger.insertAdjacentElement("afterend", overlay);
      await overlay.updateComplete;
      overlay.open = true;
      return overlay.dispose;
    }
    const options = interactionOrOptions;
    overlay.append(overlayContent);
    overlay.delayed = options.delayed || overlayContent.hasAttribute("delayed");
    overlay.receivesFocus = (_c = options.receivesFocus) != null ? _c : "auto";
    overlay.triggerElement = options.trigger || null;
    overlay.type = options.type || "modal";
    overlay.offset = (_d = options.offset) != null ? _d : 6;
    overlay.placement = options.placement;
    overlay.willPreventClose = !!options.notImmediatelyClosable;
    overlay.updateComplete.then(() => {
      overlay.open = true;
    });
    return overlay;
  }
}
//# sourceMappingURL=AbstractOverlay.dev.js.map
