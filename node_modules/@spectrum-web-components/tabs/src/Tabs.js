"use strict";var h=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var o=(n,a,e,t)=>{for(var i=t>1?void 0:t?b(a,e):a,s=n.length-1,l;s>=0;s--)(l=n[s])&&(i=(t?l(a,e,i):l(i))||i);return t&&i&&h(a,e,i),i};import{css as p,html as f,SizedMixin as m}from"@spectrum-web-components/base";import{property as r,query as d}from"@spectrum-web-components/base/src/decorators.js";import{classMap as v,ifDefined as u}from"@spectrum-web-components/base/src/directives.js";import{IntersectionController as S}from"@lit-labs/observers/intersection-controller.js";import{ResizeController as g}from"@lit-labs/observers/resize-controller.js";import{Focusable as y}from"@spectrum-web-components/shared";import{RovingTabindexController as E}from"@spectrum-web-components/reactive-controllers/src/RovingTabindex.js";import C from"./tabs.css.js";import T from"./tabs-sizes.css.js";export const ScaledIndicator={baseSize:100,noSelectionStyle:"transform: translateX(0px) scaleX(0) scaleY(0)",transformX(n,a){const e=a/this.baseSize;return`transform: translateX(${n}px) scaleX(${e});`},transformY(n,a){const e=a/this.baseSize;return`transform: translateY(${n}px) scaleY(${e});`},baseStyles(){return p`
            :host([direction='vertical-right']) #selection-indicator,
            :host([direction='vertical']) #selection-indicator {
                height: ${this.baseSize}px;
            }
            :host([dir][direction='horizontal']) #selection-indicator {
                width: ${this.baseSize}px;
            }
        `}};export class Tabs extends m(y,{noDefaultSize:!0}){constructor(){super();this.auto=!1;this.compact=!1;this.direction="horizontal";this.emphasized=!1;this.label="";this.enableTabsScroll=!1;this.quiet=!1;this.selectionIndicatorStyle=ScaledIndicator.noSelectionStyle;this.shouldAnimate=!1;this.selected="";this._tabs=[];this.resizeController=new g(this,{callback:()=>{this.updateSelectionIndicator()}});this.rovingTabindexController=new E(this,{focusInIndex:e=>{let t=0;return e.find((s,l)=>{const c=this.selected?!s.disabled&&s.value===this.selected:!s.disabled;return t=l,c})?t:-1},direction:()=>"both",elementEnterAction:e=>{this.auto&&(this.shouldAnimate=!0,this.selectTarget(e))},elements:()=>this.tabs,isFocusableElement:e=>!e.disabled,listenerScope:()=>this.tabList});this.onTabsScroll=()=>{this.dispatchEvent(new Event("sp-tabs-scroll",{bubbles:!0,composed:!0}))};this.onClick=e=>{if(this.disabled)return;const t=e.composedPath().find(i=>i.parentElement===this);!t||t.disabled||(this.shouldAnimate=!0,this.selectTarget(t))};this.onKeyDown=e=>{if(e.code==="Enter"||e.code==="Space"){e.preventDefault();const t=e.target;t&&this.selectTarget(t)}};this.updateCheckedState=()=>{if(this.tabs.forEach(e=>{e.removeAttribute("selected")}),this.selected){const e=this.tabs.find(t=>t.value===this.selected);e?e.selected=!0:this.selected=""}else{const e=this.tabs[0];e&&e.setAttribute("tabindex","0")}this.updateSelectionIndicator()};this.updateSelectionIndicator=async()=>{const e=this.tabs.find(s=>s.selected);if(!e){this.selectionIndicatorStyle=ScaledIndicator.noSelectionStyle;return}await Promise.all([e.updateComplete,document.fonts?document.fonts.ready:Promise.resolve()]);const{width:t,height:i}=e.getBoundingClientRect();this.selectionIndicatorStyle=this.direction==="horizontal"?ScaledIndicator.transformX(e.offsetLeft,t):ScaledIndicator.transformY(e.offsetTop,i)};new S(this,{config:{root:null,rootMargin:"0px",threshold:[0,1]},callback:()=>{this.updateSelectionIndicator()}})}static get styles(){return[T,C,ScaledIndicator.baseStyles()]}set tabs(e){e!==this.tabs&&(this._tabs.forEach(t=>{this.resizeController.unobserve(t)}),e.forEach(t=>{this.resizeController.observe(t)}),this._tabs=e,this.rovingTabindexController.clearElementCache())}get tabs(){return this._tabs}get focusElement(){return this.rovingTabindexController.focusInElement||this}scrollTabs(e,t="smooth"){var i;(i=this.tabList)==null||i.scrollBy({left:e,top:0,behavior:t})}get scrollState(){if(this.tabList){const{scrollLeft:e,clientWidth:t,scrollWidth:i}=this.tabList,s=Math.abs(e)>0,l=Math.ceil(Math.abs(e))<i-t;return{canScrollLeft:this.dir==="ltr"?s:l,canScrollRight:this.dir==="ltr"?l:s}}return{}}manageAutoFocus(){const t=[...this.children].map(i=>typeof i.updateComplete!="undefined"?i.updateComplete:Promise.resolve(!0));Promise.all(t).then(()=>super.manageAutoFocus())}managePanels({target:e}){e.assignedElements().map(i=>{const{value:s,id:l}=i,c=this.querySelector(`[role="tab"][value="${s}"]`);c&&(c.setAttribute("aria-controls",l),i.setAttribute("aria-labelledby",c.id)),i.selected=s===this.selected})}render(){return f`
            <div
                class=${v({scroll:this.enableTabsScroll})}
                aria-label=${u(this.label?this.label:void 0)}
                @click=${this.onClick}
                @keydown=${this.onKeyDown}
                @scroll=${this.onTabsScroll}
                id="list"
                role="tablist"
                part="tablist"
            >
                <slot @slotchange=${this.onSlotChange}></slot>
                <div
                    id="selection-indicator"
                    class=${u(this.shouldAnimate?void 0:"first-position")}
                    style=${this.selectionIndicatorStyle}
                    role="presentation"
                ></div>
            </div>
            <slot name="tab-panel" @slotchange=${this.managePanels}></slot>
        `}willUpdate(e){if(!this.hasUpdated){const t=this.querySelector(":scope > [selected]");t&&this.selectTarget(t)}if(super.willUpdate(e),e.has("selected")){if(this.tabs.length&&this.updateCheckedState(),e.get("selected")){const i=this.querySelector(`[role="tabpanel"][value="${e.get("selected")}"]`);i&&(i.selected=!1)}const t=this.querySelector(`[role="tabpanel"][value="${this.selected}"]`);t&&(t.selected=!0)}e.has("direction")&&(this.direction==="horizontal"?this.removeAttribute("aria-orientation"):this.setAttribute("aria-orientation","vertical")),e.has("dir")&&this.updateSelectionIndicator(),e.has("disabled")&&(this.disabled?this.setAttribute("aria-disabled","true"):this.removeAttribute("aria-disabled")),!this.shouldAnimate&&typeof e.get("shouldAnimate")!="undefined"&&(this.shouldAnimate=!0)}selectTarget(e){const t=e.getAttribute("value");if(t){const i=this.selected;this.selected=t,this.dispatchEvent(new Event("change",{cancelable:!0}))||(this.selected=i)}}onSlotChange(){this.tabs=this.slotEl.assignedElements().filter(e=>e.getAttribute("role")==="tab"),this.updateCheckedState()}connectedCallback(){super.connectedCallback(),window.addEventListener("resize",this.updateSelectionIndicator),"fonts"in document&&document.fonts.addEventListener("loadingdone",this.updateSelectionIndicator)}disconnectedCallback(){window.removeEventListener("resize",this.updateSelectionIndicator),"fonts"in document&&document.fonts.removeEventListener("loadingdone",this.updateSelectionIndicator),super.disconnectedCallback()}}o([r({type:Boolean})],Tabs.prototype,"auto",2),o([r({type:Boolean,reflect:!0})],Tabs.prototype,"compact",2),o([r({reflect:!0})],Tabs.prototype,"dir",2),o([r({reflect:!0})],Tabs.prototype,"direction",2),o([r({type:Boolean,reflect:!0})],Tabs.prototype,"emphasized",2),o([r()],Tabs.prototype,"label",2),o([r({type:Boolean})],Tabs.prototype,"enableTabsScroll",2),o([r({type:Boolean,reflect:!0})],Tabs.prototype,"quiet",2),o([r({attribute:!1})],Tabs.prototype,"selectionIndicatorStyle",2),o([r({attribute:!1})],Tabs.prototype,"shouldAnimate",2),o([d("slot")],Tabs.prototype,"slotEl",2),o([d("#list")],Tabs.prototype,"tabList",2),o([r({reflect:!0})],Tabs.prototype,"selected",2);
//# sourceMappingURL=Tabs.js.map
