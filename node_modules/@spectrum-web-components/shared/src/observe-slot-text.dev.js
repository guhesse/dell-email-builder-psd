"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import {
  property,
  queryAssignedNodes
} from "@spectrum-web-components/base/src/decorators.js";
import { MutationController } from "@lit-labs/observers/mutation_controller.js";
const assignedNodesList = Symbol("assignedNodes");
export function ObserveSlotText(constructor, slotName) {
  var _a;
  class SlotTextObservingElement extends constructor {
    constructor(...args) {
      super(args);
      this.slotHasContent = false;
      new MutationController(this, {
        config: {
          characterData: true,
          subtree: true
        },
        callback: (mutationsList) => {
          for (const mutation of mutationsList) {
            if (mutation.type === "characterData") {
              this.manageTextObservedSlot();
              return;
            }
          }
        }
      });
    }
    manageTextObservedSlot() {
      if (!this[assignedNodesList])
        return;
      const assignedNodes = [...this[assignedNodesList]].filter(
        (node) => {
          if (node.tagName) {
            return true;
          }
          return node.textContent ? node.textContent.trim() : false;
        }
      );
      this.slotHasContent = assignedNodes.length > 0;
    }
    update(changedProperties) {
      if (!this.hasUpdated) {
        const { childNodes } = this;
        const textNodes = [...childNodes].filter((node) => {
          if (node.tagName) {
            return slotName ? node.getAttribute("slot") === slotName : !node.hasAttribute("slot");
          }
          return node.textContent ? node.textContent.trim() : false;
        });
        this.slotHasContent = textNodes.length > 0;
      }
      super.update(changedProperties);
    }
    firstUpdated(changedProperties) {
      super.firstUpdated(changedProperties);
      this.updateComplete.then(() => {
        this.manageTextObservedSlot();
      });
    }
  }
  _a = assignedNodesList;
  __decorateClass([
    property({ type: Boolean, attribute: false })
  ], SlotTextObservingElement.prototype, "slotHasContent", 2);
  __decorateClass([
    queryAssignedNodes(slotName, true)
  ], SlotTextObservingElement.prototype, _a, 2);
  return SlotTextObservingElement;
}
//# sourceMappingURL=observe-slot-text.dev.js.map
