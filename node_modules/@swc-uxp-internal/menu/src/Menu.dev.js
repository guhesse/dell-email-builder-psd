"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import {
  html,
  SpectrumElement
} from "@spectrum-web-components/base";
import {
  property,
  query
} from "@spectrum-web-components/base/src/decorators.js";
import { MenuItem } from "./MenuItem.dev.js";
import menuStyles from "./menu.css.js";
function elementIsOrContains(el, isOrContains) {
  return !!isOrContains && (el === isOrContains || el.contains(isOrContains));
}
export class Menu extends SpectrumElement {
  constructor() {
    super();
    this.isSubmenu = false;
    this.label = "";
    this.value = "";
    this.valueSeparator = ",";
    this.selected = [];
    this.selectedItems = [];
    this.childItemSet = /* @__PURE__ */ new Set();
    this.focusedItemIndex = 0;
    this.focusInItemIndex = 0;
    this.selectedItemsMap = /* @__PURE__ */ new Map();
    this._willUpdateItems = false;
    this._notFirstUpdated = false;
    this.cacheUpdated = Promise.resolve();
    this.addEventListener(
      "sp-menu-item-added-or-updated",
      this.onSelectableItemAddedOrUpdated
    );
    this.addEventListener(
      "sp-menu-item-added-or-updated",
      this.onFocusableItemAddedOrUpdated,
      {
        capture: true
      }
    );
    this.addEventListener("sp-menu-item-removed", this.removeChildItem);
    this.addEventListener("click", this.onClick);
    this.addEventListener("focusin", this.handleFocusin);
  }
  static get styles() {
    return [menuStyles];
  }
  get childItems() {
    if (!this.cachedChildItems) {
      this.cachedChildItems = this.updateCachedMenuItems();
    }
    return this.cachedChildItems;
  }
  updateCachedMenuItems() {
    this.cachedChildItems = [];
    const slotElements = this.menuSlot ? this.menuSlot.assignedElements({ flatten: true }) : [];
    for (const slotElement of slotElements) {
      const childMenuItems = slotElement instanceof MenuItem ? [slotElement] : [...slotElement.querySelectorAll(`*`)];
      for (const childMenuItem of childMenuItems) {
        if (this.childItemSet.has(childMenuItem)) {
          this.cachedChildItems.push(childMenuItem);
        }
      }
    }
    return this.cachedChildItems;
  }
  get childRole() {
    if (this.resolvedRole === "listbox") {
      return "option";
    }
    switch (this.resolvedSelects) {
      case "single":
        return "menuitemradio";
      case "multiple":
        return "menuitemcheckbox";
      default:
        return "menuitem";
    }
  }
  get ownRole() {
    return "menu";
  }
  onFocusableItemAddedOrUpdated(event) {
    var _a;
    if (event.item.menuData.focusRoot) {
      this.tabIndex = -1;
    }
    event.focusRoot = this;
    this.addChildItem(event.item);
    if (this.selects === "inherit") {
      this.resolvedSelects = "inherit";
      this.resolvedRole = ((_a = event.currentAncestorWithSelects) == null ? void 0 : _a.getAttribute(
        "role"
      )) || this.getAttribute("role") || void 0;
    } else if (this.selects) {
      this.resolvedRole = this.getAttribute("role") || void 0;
      this.resolvedSelects = this.selects;
      event.currentAncestorWithSelects = this;
    } else {
      this.resolvedRole = this.getAttribute("role") || void 0;
      this.resolvedSelects = this.resolvedRole === "none" ? "ignore" : "none";
    }
  }
  onSelectableItemAddedOrUpdated(event) {
    const selects = this.resolvedSelects === "single" || this.resolvedSelects === "multiple";
    if ((selects || !this.selects && this.resolvedSelects !== "ignore") && !event.item.menuData.selectionRoot) {
      event.item.setRole(this.childRole);
      event.selectionRoot = this;
    }
  }
  addChildItem(item) {
    this.childItemSet.add(item);
    this.handleItemsChanged();
  }
  async removeChildItem(event) {
    this.childItemSet.delete(event.item);
    this.cachedChildItems = void 0;
    if (event.item.focused) {
      this.handleItemsChanged();
      await this.updateComplete;
      this.focus();
    }
  }
  focus({ preventScroll } = {}) {
    if (!this.childItems.length || this.childItems.every((childItem) => childItem.disabled)) {
      return;
    }
    if (this.childItems.some(
      (childItem) => childItem.menuData.focusRoot !== this
    )) {
      super.focus({ preventScroll });
      return;
    }
    this.focusMenuItemByOffset(0);
    super.focus({ preventScroll });
    const selectedItem = this.querySelector("[selected]");
    if (selectedItem && !preventScroll) {
      selectedItem.scrollIntoView({ block: "nearest" });
    }
  }
  onClick(event) {
    if (event.defaultPrevented) {
      return;
    }
    const path = event.composedPath();
    const target = path.find((el) => {
      if (!(el instanceof Element)) {
        return false;
      }
      return el.getAttribute("role") === this.childRole;
    });
    if ((target == null ? void 0 : target.href) && target.href.length) {
      this.dispatchEvent(
        new Event("change", {
          bubbles: true,
          composed: true
        })
      );
      return;
    } else if ((target == null ? void 0 : target.menuData.selectionRoot) === this && this.childItems.length) {
      event.preventDefault();
      if (target.hasSubmenu || target.open) {
        return;
      }
      this.selectOrToggleItem(target);
    } else {
      return;
    }
    this.prepareToCleanUp();
  }
  handleFocusin(event) {
    var _a;
    const isOrContainsRelatedTarget = elementIsOrContains(
      this,
      event.relatedTarget
    );
    if (isOrContainsRelatedTarget || this.childItems.some(
      (childItem) => childItem.menuData.focusRoot !== this
    )) {
      return;
    }
    const activeElement = this.getRootNode().activeElement;
    const selectionRoot = ((_a = this.childItems[this.focusedItemIndex]) == null ? void 0 : _a.menuData.selectionRoot) || this;
    if (activeElement !== selectionRoot || !isOrContainsRelatedTarget) {
      selectionRoot.focus({ preventScroll: true });
      if (activeElement && this.focusedItemIndex === 0) {
        const offset = this.childItems.findIndex(
          (childItem) => childItem === activeElement
        );
        if (offset > 0) {
          this.focusMenuItemByOffset(offset);
        }
      }
    }
    this.startListeningToKeyboard();
  }
  startListeningToKeyboard() {
    this.addEventListener("keydown", this.handleKeydown);
    this.addEventListener("focusout", this.handleFocusout);
  }
  handleFocusout(event) {
    if (elementIsOrContains(this, event.relatedTarget)) {
      event.composedPath()[0].focused = false;
      return;
    }
    this.stopListeningToKeyboard();
    if (event.target === this && this.childItems.some(
      (childItem) => childItem.menuData.focusRoot === this
    )) {
      const focusedItem = this.childItems[this.focusedItemIndex];
      if (focusedItem) {
        focusedItem.focused = false;
      }
    }
    this.removeAttribute("aria-activedescendant");
  }
  stopListeningToKeyboard() {
    this.removeEventListener("keydown", this.handleKeydown);
    this.removeEventListener("focusout", this.handleFocusout);
  }
  async selectOrToggleItem(targetItem) {
    const resolvedSelects = this.resolvedSelects;
    const oldSelectedItemsMap = new Map(this.selectedItemsMap);
    const oldSelected = this.selected.slice();
    const oldSelectedItems = this.selectedItems.slice();
    const oldValue = this.value;
    this.childItems[this.focusedItemIndex].focused = false;
    this.focusedItemIndex = this.childItems.indexOf(targetItem);
    this.forwardFocusVisibleToItem(targetItem);
    if (resolvedSelects === "multiple") {
      if (this.selectedItemsMap.has(targetItem)) {
        this.selectedItemsMap.delete(targetItem);
      } else {
        this.selectedItemsMap.set(targetItem, true);
      }
      const selected = [];
      const selectedItems = [];
      this.childItemSet.forEach((childItem) => {
        if (childItem.menuData.selectionRoot !== this)
          return;
        if (this.selectedItemsMap.has(childItem)) {
          selected.push(childItem.value);
          selectedItems.push(childItem);
        }
      });
      this.selected = selected;
      this.selectedItems = selectedItems;
      this.value = this.selected.join(this.valueSeparator);
    } else {
      this.selectedItemsMap.clear();
      this.selectedItemsMap.set(targetItem, true);
      this.value = targetItem.value;
      this.selected = [targetItem.value];
      this.selectedItems = [targetItem];
    }
    await this.updateComplete;
    const applyDefault = this.dispatchEvent(
      new Event("change", {
        cancelable: true,
        bubbles: true,
        composed: true
      })
    );
    if (!applyDefault) {
      this.selected = oldSelected;
      this.selectedItems = oldSelectedItems;
      this.selectedItemsMap = oldSelectedItemsMap;
      this.value = oldValue;
      return;
    }
    if (resolvedSelects === "single") {
      for (const oldItem of oldSelectedItemsMap.keys()) {
        if (oldItem !== targetItem) {
          oldItem.selected = false;
        }
      }
      targetItem.selected = true;
    } else if (resolvedSelects === "multiple") {
      targetItem.selected = !targetItem.selected;
    }
  }
  navigateWithinMenu(event) {
    const { code } = event;
    const lastFocusedItem = this.childItems[this.focusedItemIndex];
    const direction = code === "ArrowDown" ? 1 : -1;
    const itemToFocus = this.focusMenuItemByOffset(direction);
    if (itemToFocus === lastFocusedItem) {
      return;
    }
    event.preventDefault();
    itemToFocus.scrollIntoView({ block: "nearest" });
  }
  navigateBetweenRelatedMenus(code) {
    const shouldOpenSubmenu = this.isLTR && code === "ArrowRight" || !this.isLTR && code === "ArrowLeft";
    const shouldCloseSelfAsSubmenu = this.isLTR && code === "ArrowLeft" || !this.isLTR && code === "ArrowRight";
    if (shouldOpenSubmenu) {
      const lastFocusedItem = this.childItems[this.focusedItemIndex];
      if (lastFocusedItem.hasSubmenu) {
        this.blur();
        lastFocusedItem.openOverlay();
      }
    } else if (shouldCloseSelfAsSubmenu && this.isSubmenu) {
      this.dispatchEvent(new Event("close", { bubbles: true }));
    }
  }
  handleKeydown(event) {
    var _a;
    const { code } = event;
    if (code === "Tab") {
      this.prepareToCleanUp();
      return;
    }
    if (code === "Space") {
      const lastFocusedItem = this.childItems[this.focusedItemIndex];
      if (lastFocusedItem.hasSubmenu) {
        this.blur();
        lastFocusedItem.openOverlay();
        return;
      }
    }
    if (code === "Space" || code === "Enter") {
      (_a = this.childItems[this.focusedItemIndex]) == null ? void 0 : _a.click();
      return;
    }
    if (code === "ArrowDown" || code === "ArrowUp") {
      this.navigateWithinMenu(event);
      return;
    }
    this.navigateBetweenRelatedMenus(code);
  }
  focusMenuItemByOffset(offset) {
    const step = offset || 1;
    const focusedItem = this.childItems[this.focusedItemIndex];
    focusedItem.focused = false;
    this.focusedItemIndex = (this.childItems.length + this.focusedItemIndex + offset) % this.childItems.length;
    let itemToFocus = this.childItems[this.focusedItemIndex];
    let availableItems = this.childItems.length;
    while (itemToFocus.disabled && availableItems) {
      availableItems -= 1;
      this.focusedItemIndex = (this.childItems.length + this.focusedItemIndex + step) % this.childItems.length;
      itemToFocus = this.childItems[this.focusedItemIndex];
    }
    if (!(itemToFocus == null ? void 0 : itemToFocus.disabled)) {
      this.forwardFocusVisibleToItem(itemToFocus);
    }
    return itemToFocus;
  }
  prepareToCleanUp() {
    document.addEventListener(
      "focusout",
      () => {
        requestAnimationFrame(() => {
          const focusedItem = this.childItems[this.focusedItemIndex];
          if (focusedItem) {
            focusedItem.focused = false;
            this.updateSelectedItemIndex();
          }
        });
      },
      { once: true }
    );
  }
  updateSelectedItemIndex() {
    let firstOrFirstSelectedIndex = 0;
    const selectedItemsMap = /* @__PURE__ */ new Map();
    const selected = [];
    const selectedItems = [];
    let itemIndex = this.childItems.length;
    while (itemIndex) {
      itemIndex -= 1;
      const childItem = this.childItems[itemIndex];
      if (childItem.menuData.selectionRoot === this) {
        if (childItem.selected) {
          firstOrFirstSelectedIndex = itemIndex;
          selectedItemsMap.set(childItem, true);
          selected.unshift(childItem.value);
          selectedItems.unshift(childItem);
        }
        if (itemIndex !== firstOrFirstSelectedIndex) {
          childItem.focused = false;
        }
      }
    }
    selectedItems.map((item, i) => {
      if (i > 0) {
        item.focused = false;
      }
    });
    this.selectedItemsMap = selectedItemsMap;
    this.selected = selected;
    this.selectedItems = selectedItems;
    this.value = this.selected.join(this.valueSeparator);
    this.focusedItemIndex = firstOrFirstSelectedIndex;
    this.focusInItemIndex = firstOrFirstSelectedIndex;
  }
  handleItemsChanged() {
    this.cachedChildItems = void 0;
    if (!this._willUpdateItems) {
      let resolve = () => {
        return;
      };
      this.cacheUpdated = new Promise((res) => resolve = res);
      this._willUpdateItems = true;
      window.requestAnimationFrame(() => {
        if (this.cachedChildItems === void 0) {
          this.updateSelectedItemIndex();
          this.updateItemFocus();
        }
        this._willUpdateItems = false;
        resolve();
      });
    }
  }
  updateItemFocus() {
    if (this.childItems.length == 0) {
      return;
    }
    const focusInItem = this.childItems[this.focusInItemIndex];
    if (this.getRootNode().activeElement === focusInItem.menuData.focusRoot) {
      this.forwardFocusVisibleToItem(focusInItem);
    }
  }
  forwardFocusVisibleToItem(item) {
    if (item.menuData.focusRoot !== this) {
      return;
    }
    item.focused = this.hasVisibleFocusInTree();
    this.setAttribute("aria-activedescendant", item.id);
    if (item.menuData.selectionRoot && item.menuData.selectionRoot !== this) {
      item.menuData.selectionRoot.focus();
    }
  }
  render() {
    return html`
            <slot></slot>
        `;
  }
  firstUpdated(changed) {
    super.firstUpdated(changed);
    if (!this.hasAttribute("tabindex")) {
      const role = this.getAttribute("role");
      if (role === "group") {
        this.tabIndex = -1;
      } else if (role !== "none") {
        this.tabIndex = 0;
      }
    }
    const updates = [
      new Promise((res) => requestAnimationFrame(() => res(true)))
    ];
    [...this.children].forEach((item) => {
      if (item.localName === "sp-menu-item") {
        updates.push(item.updateComplete);
      }
    });
    this.childItemsUpdated = Promise.all(updates);
  }
  updated(changes) {
    super.updated(changes);
    if (changes.has("selects") && this._notFirstUpdated) {
      this.selectsChanged();
    }
    if (changes.has("label")) {
      if (this.label) {
        this.setAttribute("aria-label", this.label);
      } else {
        this.removeAttribute("aria-label");
      }
    }
    this._notFirstUpdated = true;
  }
  selectsChanged() {
    const updates = [
      new Promise((res) => requestAnimationFrame(() => res(true)))
    ];
    this.childItemSet.forEach((childItem) => {
      updates.push(childItem.triggerUpdate());
    });
    this.childItemsUpdated = Promise.all(updates);
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", this.ownRole);
    }
    this.updateComplete.then(() => this.updateItemFocus());
  }
  async getUpdateComplete() {
    const complete = await super.getUpdateComplete();
    await this.childItemsUpdated;
    await this.cacheUpdated;
    return complete;
  }
}
__decorateClass([
  property({ type: String, reflect: true })
], Menu.prototype, "label", 2);
__decorateClass([
  property({ type: String, reflect: true })
], Menu.prototype, "selects", 2);
__decorateClass([
  property({ type: String })
], Menu.prototype, "value", 2);
__decorateClass([
  property({ type: String, attribute: "value-separator" })
], Menu.prototype, "valueSeparator", 2);
__decorateClass([
  property({ attribute: false })
], Menu.prototype, "selected", 2);
__decorateClass([
  property({ attribute: false })
], Menu.prototype, "selectedItems", 2);
__decorateClass([
  query("slot:not([name])")
], Menu.prototype, "menuSlot", 2);
//# sourceMappingURL=Menu.dev.js.map
