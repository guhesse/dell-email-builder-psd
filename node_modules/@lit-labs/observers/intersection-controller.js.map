{"version":3,"file":"intersection-controller.js","sources":["src/intersection-controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element/reactive-controller.js';\n\n/**\n * The callback function for a IntersectionController.\n */\nexport type IntersectionValueCallback<T = unknown> = (\n  ...args: Parameters<IntersectionObserverCallback>\n) => T;\n\n/**\n * The config options for a IntersectionController.\n */\nexport interface IntersectionControllerConfig<T = unknown> {\n  /**\n   * Configuration object for the IntersectionObserver.\n   */\n  config?: IntersectionObserverInit;\n  /**\n   * The element to observe. In addition to configuring the target here,\n   * the `observe` method can be called to observe additional targets. When not\n   * specified, the target defaults to the `host`. If set to `null`, no target\n   * is automatically observed. Only the configured target will be re-observed\n   * if the host connects again after unobserving via disconnection.\n   */\n  target?: Element | null;\n  /**\n   * The callback used to process detected changes into a value stored\n   * in the controller's `value` property.\n   */\n  callback?: IntersectionValueCallback<T>;\n  /**\n   * An IntersectionObserver reports the initial intersection state\n   * when observe is called. Setting this flag to true skips processing this\n   * initial state for cases when this is unnecessary.\n   */\n  skipInitial?: boolean;\n}\n\n/**\n * IntersectionController is a ReactiveController that integrates an\n * IntersectionObserver with a ReactiveControllerHost's reactive update\n * lifecycle. This is typically a ReactiveElement or LitElement.\n * IntersectionObservers can be used to detect when a target element\n * \"intersects\" is visible inside of) another element or the viewport by\n * default, where intersect means \"visible inside of.\"\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the IntersectionObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class IntersectionController<T = unknown> implements ReactiveController {\n  private _host: ReactiveControllerHost;\n  private _targets = new Set<Element>();\n  private _observer!: IntersectionObserver;\n  private _skipInitial = false;\n  /**\n   * Flag used to help manage calling the `callback` when observe is called\n   * and `skipInitial` is set to true. Note that unlike the other observers\n   * IntersectionObserver *does* report its initial state (e.g. whether or not\n   * there is an intersection). This flag is used to avoid handling this\n   * state if `skipInitial` is true.\n   */\n  private _unobservedUpdate = false;\n  /**\n   * The result of processing the observer's changes via the `callback`\n   * function.\n   */\n  value?: T;\n  /**\n   * Function that returns a value processed from the observer's changes.\n   * The result is stored in the `value` property.\n   */\n  callback?: IntersectionValueCallback<T>;\n  constructor(\n    host: ReactiveControllerHost & Element,\n    {target, config, callback, skipInitial}: IntersectionControllerConfig<T>\n  ) {\n    this._host = host;\n    // Target defaults to `host` unless explicitly `null`.\n    if (target !== null) {\n      this._targets.add(target ?? host);\n    }\n    this._skipInitial = skipInitial ?? this._skipInitial;\n    this.callback = callback;\n    // Check browser support.\n    if (!window.IntersectionObserver) {\n      console.warn(\n        `IntersectionController error: browser does not support IntersectionObserver.`\n      );\n      return;\n    }\n    this._observer = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]) => {\n        const unobservedUpdate = this._unobservedUpdate;\n        this._unobservedUpdate = false;\n        if (this._skipInitial && unobservedUpdate) {\n          return;\n        }\n        this.handleChanges(entries);\n        this._host.requestUpdate();\n      },\n      config\n    );\n    host.addController(this);\n  }\n\n  /**\n   * Process the observer's changes with the controller's `callback`\n   * function to produce a result stored in the `value` property.\n   */\n  protected handleChanges(entries: IntersectionObserverEntry[]) {\n    this.value = this.callback?.(entries, this._observer);\n  }\n\n  hostConnected() {\n    for (const target of this._targets) {\n      this.observe(target);\n    }\n  }\n\n  hostDisconnected() {\n    this.disconnect();\n  }\n\n  async hostUpdated() {\n    // Eagerly deliver any changes that happened during update.\n    const pendingRecords = this._observer.takeRecords();\n    if (pendingRecords.length) {\n      this.handleChanges(pendingRecords);\n    }\n  }\n\n  /**\n   * Observe the target element. The controller's `target` is automatically\n   * observed when the host connects.\n   * @param target Element to observe\n   */\n  observe(target: Element) {\n    this._targets.add(target);\n    // Note, this will always trigger the callback since the initial\n    // intersection state is reported.\n    this._observer.observe(target);\n    this._unobservedUpdate = true;\n  }\n\n  /**\n   * Unobserve the target element.\n   * @param target Element to unobserve\n   */\n  unobserve(target: Element) {\n    this._targets.delete(target);\n    this._observer.unobserve(target);\n  }\n\n  /**\n   * Disconnects the observer. This is done automatically when the host\n   * disconnects.\n   */\n  protected disconnect() {\n    this._observer.disconnect();\n  }\n}\n"],"names":["IntersectionController","constructor","host","target","config","callback","skipInitial","this","_targets","Set","_skipInitial","_unobservedUpdate","_host","add","window","IntersectionObserver","_observer","entries","unobservedUpdate","handleChanges","requestUpdate","addController","console","warn","value","hostConnected","observe","hostDisconnected","disconnect","hostUpdated","pendingRecords","takeRecords","length","unobserve","delete"],"mappings":"MA8DaA,EAuBX,WAAAC,CACEC,GACAC,OAACA,EAAMC,OAAEA,EAAMC,SAAEA,EAAQC,YAAEA,IAvBrBC,KAAAC,EAAW,IAAIC,IAEfF,KAAYG,GAAG,EAQfH,KAAiBI,GAAG,EAe1BJ,KAAKK,EAAQV,EAEE,OAAXC,GACFI,KAAKC,EAASK,IAAIV,GAAUD,GAE9BK,KAAKG,EAAeJ,GAAeC,KAAKG,EACxCH,KAAKF,SAAWA,EAEXS,OAAOC,sBAMZR,KAAKS,EAAY,IAAID,sBAClBE,IACC,MAAMC,EAAmBX,KAAKI,EAC9BJ,KAAKI,GAAoB,EACrBJ,KAAKG,GAAgBQ,IAGzBX,KAAKY,cAAcF,GACnBV,KAAKK,EAAMQ,gBAAe,GAE5BhB,GAEFF,EAAKmB,cAAcd,OAjBjBe,QAAQC,KACN,+EAiBL,CAMS,aAAAJ,CAAcF,GACtBV,KAAKiB,MAAQjB,KAAKF,WAAWY,EAASV,KAAKS,EAC5C,CAED,aAAAS,GACE,IAAK,MAAMtB,KAAUI,KAAKC,EACxBD,KAAKmB,QAAQvB,EAEhB,CAED,gBAAAwB,GACEpB,KAAKqB,YACN,CAED,iBAAMC,GAEJ,MAAMC,EAAiBvB,KAAKS,EAAUe,cAClCD,EAAeE,QACjBzB,KAAKY,cAAcW,EAEtB,CAOD,OAAAJ,CAAQvB,GACNI,KAAKC,EAASK,IAAIV,GAGlBI,KAAKS,EAAUU,QAAQvB,GACvBI,KAAKI,GAAoB,CAC1B,CAMD,SAAAsB,CAAU9B,GACRI,KAAKC,EAAS0B,OAAO/B,GACrBI,KAAKS,EAAUiB,UAAU9B,EAC1B,CAMS,UAAAyB,GACRrB,KAAKS,EAAUY,YAChB"}