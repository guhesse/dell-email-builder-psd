/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { html } from 'lit';
import { directive, PartType } from 'lit/directive.js';
import { AsyncDirective } from 'lit/async-directive.js';
import { repeat } from 'lit/directives/repeat.js';
import { Virtualizer } from './Virtualizer.js';
export { virtualizerRef } from './Virtualizer.js';
export const defaultKeyFunction = (item) => item;
export const defaultRenderItem = (item, idx) => html `${idx}: ${JSON.stringify(item, null, 2)}`;
class VirtualizeDirective extends AsyncDirective {
    constructor(part) {
        super(part);
        this._virtualizer = null;
        this._first = 0;
        this._last = -1;
        this._renderItem = (item, idx) => defaultRenderItem(item, idx + this._first);
        this._keyFunction = (item, idx) => defaultKeyFunction(item, idx + this._first);
        this._items = [];
        if (part.type !== PartType.CHILD) {
            throw new Error('The virtualize directive can only be used in child expressions');
        }
    }
    render(config) {
        if (config) {
            this._setFunctions(config);
        }
        const itemsToRender = [];
        // TODO (graynorton): Is this the best / only place to ensure
        // that _last isn't outside the current bounds of the items array?
        // Not sure we should ever arrive here with it out of bounds.
        // Repro case for original issue: https://tinyurl.com/yes8b2e6
        const lastItem = Math.min(this._items.length, this._last + 1);
        if (this._first >= 0 && this._last >= this._first) {
            for (let i = this._first; i < lastItem; i++) {
                itemsToRender.push(this._items[i]);
            }
        }
        return repeat(itemsToRender, this._keyFunction, this._renderItem);
    }
    update(part, [config]) {
        this._setFunctions(config);
        this._items = config.items || [];
        if (this._virtualizer) {
            this._updateVirtualizerConfig(part, config);
        }
        else {
            this._initialize(part, config);
        }
        return this.render();
    }
    _updateVirtualizerConfig(part, config) {
        const compatible = this._virtualizer.updateLayoutConfig(config.layout || {});
        if (!compatible) {
            const hostElement = part.parentNode;
            this._makeVirtualizer(hostElement, config);
        }
        this._virtualizer.items = this._items;
    }
    _setFunctions(config) {
        const { renderItem, keyFunction } = config;
        if (renderItem) {
            this._renderItem = (item, idx) => renderItem(item, idx + this._first);
        }
        if (keyFunction) {
            this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);
        }
    }
    _makeVirtualizer(hostElement, config) {
        if (this._virtualizer) {
            this._virtualizer.disconnected();
        }
        const { layout, scroller, items } = config;
        this._virtualizer = new Virtualizer({ hostElement, layout, scroller });
        this._virtualizer.items = items;
        this._virtualizer.connected();
    }
    _initialize(part, config) {
        const hostElement = part.parentNode;
        if (hostElement && hostElement.nodeType === 1) {
            hostElement.addEventListener('rangeChanged', (e) => {
                e.stopPropagation();
                this._first = e.first;
                this._last = e.last;
                this.setValue(this.render());
            });
            this._makeVirtualizer(hostElement, config);
        }
    }
    disconnected() {
        var _a;
        (_a = this._virtualizer) === null || _a === void 0 ? void 0 : _a.disconnected();
    }
    reconnected() {
        var _a;
        (_a = this._virtualizer) === null || _a === void 0 ? void 0 : _a.connected();
    }
}
export const virtualize = directive(VirtualizeDirective);
//# sourceMappingURL=virtualize.js.map