/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { GridBaseLayout } from './shared/GridBaseLayout.js';
export const masonry = (config) => Object.assign({
    type: MasonryLayout,
}, config);
const MIN = 'MIN';
const MAX = 'MAX';
export class MasonryLayout extends GridBaseLayout {
    constructor() {
        super(...arguments);
        this._RANGE_MAP_GRANULARITY = 100;
        this._positions = new Map();
        this._rangeMap = new Map();
    }
    get _defaultConfig() {
        return Object.assign({}, super._defaultConfig, {
            getAspectRatio: () => 1,
        });
    }
    set getAspectRatio(getAspectRatio) {
        this._getAspectRatio = getAspectRatio;
    }
    set items(items) {
        if (items !== this._items) {
            this._scheduleLayoutUpdate();
        }
        super.items = items;
    }
    get items() {
        return super.items;
    }
    _getItemSize(_idx) {
        return {
            [this._sizeDim]: this._metrics.itemSize1,
            [this._secondarySizeDim]: this._metrics.itemSize2,
        };
    }
    _updateLayout() {
        super._updateLayout();
        // Possibly, we want to do this somewhere else instead
        this._layOutChildren();
    }
    _getRangeMapKey(scrollPos, minOrMax) {
        const G = this._RANGE_MAP_GRANULARITY;
        return minOrMax === MIN
            ? Math.floor(scrollPos / G) * G
            : Math.ceil(scrollPos / G) * G;
    }
    _layOutChildren() {
        const G = this._RANGE_MAP_GRANULARITY;
        this._positions.clear();
        this._rangeMap.clear();
        const { rolumns, padding1, itemSize2, gap1, positions } = this._metrics;
        let nextPos = padding1.start;
        const nextPosPerRolumn = new Array(rolumns).fill(null).map((_) => nextPos);
        let nextRolumn = 0;
        let scrollSize = 0;
        let minRangeMapKey = Infinity;
        let maxRangeMapKey = -Infinity;
        this.items.forEach((item, idx) => {
            var _a;
            const aspectRatio = this._getAspectRatio(item);
            const size1 = this.direction === 'horizontal'
                ? itemSize2 * aspectRatio
                : itemSize2 / aspectRatio;
            const pos1 = nextPosPerRolumn[nextRolumn];
            const pos2 = positions[nextRolumn];
            this._positions.set(idx, {
                [this._positionDim]: pos1,
                [this._secondaryPositionDim]: pos2,
                [this._sizeDim]: size1,
                [this._secondarySizeDim]: itemSize2,
            });
            const max1 = pos1 + size1;
            const firstRangeMapKey = this._getRangeMapKey(pos1, MIN);
            if (firstRangeMapKey < minRangeMapKey) {
                minRangeMapKey = firstRangeMapKey;
            }
            const lastRangeMapKey = this._getRangeMapKey(max1, MAX);
            if (lastRangeMapKey > maxRangeMapKey) {
                maxRangeMapKey = lastRangeMapKey;
            }
            for (let n = firstRangeMapKey; n <= lastRangeMapKey; n += G) {
                const [minIdx, maxIdx] = (_a = this._rangeMap.get(n)) !== null && _a !== void 0 ? _a : [Infinity, -Infinity];
                this._rangeMap.set(n, [Math.min(idx, minIdx), Math.max(idx, maxIdx)]);
            }
            scrollSize = max1 + padding1.end;
            nextPosPerRolumn[nextRolumn] += size1 + gap1;
            nextPos = Infinity;
            nextPosPerRolumn.forEach((pos, rolumn) => {
                if (pos < nextPos) {
                    nextPos = pos;
                    nextRolumn = rolumn;
                }
            });
        });
        if (minRangeMapKey !== Infinity) {
            for (let n = 0; n < minRangeMapKey; n += G) {
                this._rangeMap.set(n, [-1, -1]);
            }
        }
        if (maxRangeMapKey !== -Infinity) {
            const maxRange = this._rangeMap.get(maxRangeMapKey);
            for (let n = maxRangeMapKey + G; n < scrollSize + G; n += G) {
                this._rangeMap.set(n, maxRange);
            }
        }
        this._scrollSize = scrollSize;
    }
    _getActiveItems() {
        var _a, _b, _c, _d;
        const metrics = this._metrics;
        const { rolumns } = metrics;
        if (rolumns === 0 || this._rangeMap.size === 0) {
            this._first = -1;
            this._last = -1;
            this._physicalMin = 0;
            this._physicalMax = 0;
        }
        else {
            const min = Math.max(0, this._scrollPosition - this._overhang);
            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);
            this._first =
                (_b = (_a = this._rangeMap.get(this._getRangeMapKey(min, MIN))) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 0;
            this._last =
                (_d = (_c = this._rangeMap.get(this._getRangeMapKey(max, MAX))) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : this.items.length - 1;
        }
    }
    _getItemPosition(idx) {
        return this._positions.get(idx);
    }
    _updateScrollSize() {
        // We calculate scrollSize in _layouOutChildren(),
        // no need to do it here
    }
}
//# sourceMappingURL=masonry.js.map